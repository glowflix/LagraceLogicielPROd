Je garde aussi tout le reste : OFFLINE-FIRST, sync Sheets en arri√®re-plan, impression auto via print_job + watcher @module.js, devise + conversion USD‚ÜíFC, queues + retry.

1) But du syst√®me (vision m√©tier et contraintes non n√©gociables)
1.1 OFFLINE-FIRST (r√®gle d‚Äôor)

Une vente ne se coupe jamais.

M√™me si :

Internet est absent,

Google Sheets est lent ou indisponible,

Apps Script √©choue,

le r√©seau ‚Äúclignote‚Äù (micro-freezes),

ou qu‚Äôil y a beaucoup de ventes.

La vente doit √™tre valid√©e en local (SQL) et l‚ÄôUI doit rester fluide.

üëâ La base de v√©rit√© imm√©diate = SQL local.
Sheets = ‚Äúcopie synchronis√©e‚Äù, jamais la v√©rit√© instantan√©e.

1.2 Sync Sheets uniquement en arri√®re-plan

La synchronisation Google Sheets :

est asynchrone,

par lots (batch),

avec retry,

et ne doit jamais ralentir le POS.

1.3 Impression automatique (s√©par√©e de la sync)

√Ä la finalisation :

tu d√©poses un print_job

un watcher dans @module.js imprime automatiquement

L‚Äôimpression est ind√©pendante de la sync et d‚ÄôInternet.

2) Architecture technique globale : 3 pipelines ind√©pendants (anti-lag / anti-plantage)

Le syst√®me doit √™tre pens√© comme 3 processus s√©par√©s (m√™me si c‚Äôest le m√™me backend, la logique doit √™tre s√©par√©e).

2.1 Pipeline A ‚Äî Vente (chemin critique POS : ultra rapide)

D√©clench√© par Finaliser dans SalesPOS.jsx :

Normaliser + appliquer r√®gles quantit√© (UI temps r√©el + backend validation finale)

Transaction SQL locale :

enregistrer facture + lignes

r√©duire stock local imm√©diatement

d√©poser sync_queue (pending)

d√©poser print_job (pending)

R√©ponse UI imm√©diate : ‚ÄúOK vente‚Äù

Interdit dans ce pipeline :

appels Google Sheets

appels externes HTTP

lecture compl√®te des feuilles

boucles lourdes

recalcul global

2.2 Pipeline B ‚Äî Sync Sheets (worker backend toutes les ~10 sec)

Toutes les ~10 secondes :

d√©tecter Internet (l√©ger)

lire sync_queue pending (et √©ligibles selon next_retry_at)

pousser en batch :

Ventes (append lignes)

Stock (update dans la feuille unit√© correspondante)

Stock de prix effectu√© (append journal)

marquer synced si succ√®s

sinon error + backoff + retry

2.3 Pipeline C ‚Äî Impression auto (watcher @module.js toutes les 1‚Äì2 sec)

Toutes les 1‚Äì2 secondes :

lire print_jobs pending

passer processing

imprimer (80mm / 80hbs)

marquer printed si succ√®s

sinon error + retry local

3) R√®gles quantit√© (c≈ìur de ton besoin) ‚Äî version finale verrouill√©e
3.1 Normalisation unit√© (avant toute r√®gle)

Transformer tout en :

carton

milliers

piece

Exemples :

‚ÄúCarton‚Äù, ‚ÄúCARTON‚Äù, ‚Äúbox‚Äù ‚Üí carton

‚ÄúMillier‚Äù, ‚ÄúMilliers‚Äù, ‚Äúmille‚Äù ‚Üí milliers

‚ÄúPiece‚Äù, ‚ÄúPi√®ce‚Äù, ‚Äúpcs‚Äù ‚Üí piece

3.2 Normalisation MARK (tol√©rance DZ)

Cr√©er markNorm :

si mark ‚àà {dz, Dz, DZ, DZN, douzain, douzaine, dizaine}
‚áí markNorm = "DZ"

sinon
‚áí markNorm = mark.trim().toUpperCase()
(ex: paque‚ÜíPAQUE, bt‚ÜíBT, pqt‚ÜíPQT, jute‚ÜíJUTE)

3.3 R√®gles finales quantit√© (d√©finitives)
A) Unit√© = carton

D√©cimal autoris√©

0.25, 0.5, 0,5, 1.75, etc.

MARK ne joue aucun r√¥le

B) Unit√© = milliers
Si markNorm = "DZ"

D√©cimal autoris√©

Exemples accept√©s :

0.5, 0,5, 0.25, 0,25, 0,50, 1, 2, 3, etc.

Donc 0,50 est accept√© (c‚Äôest 0.5).

Si markNorm ‚â† "DZ" (PAQUE / BT / PQT / JUTE / autre)

D√©cimal interdit

Quantit√© ENTIER OBLIGATOIRE et ‚â• 1

Donc l‚Äôutilisateur doit saisir : 1, 2, 3, ‚Ä¶

‚û°Ô∏è C‚Äôest ici que tu ‚Äúbloques imm√©diatement √† 1‚Äù :

pas de 0.5

pas de 0.25

pas de 0.x

pas de 0

minimum = 1

C) Unit√© = piece

D√©cimal interdit

Quantit√© ENTIER ‚â• 1

4) Comportement UI ‚Äútemps r√©el‚Äù (sans message d‚Äôerreur, seulement une logique de saisie)

Tu as demand√© : pas d‚Äôerreur bloquante, juste la logique.

4.1 Politique de saisie (qtyPolicy) par ligne

Pour chaque ligne, calculer :

allowDecimal (true/false)

minQty

step

integerOnly (true/false)

Tableau final (celui qui doit piloter l‚Äôinput)
unit	condition	allowDecimal	minQty	step
carton	(peu importe mark)	true	0.01 (ou 0.25)	0.25 / 0.5
milliers	markNorm = DZ	true	0.01 (ou 0.25)	0.25 / 0.5
milliers	markNorm ‚â† DZ	false	1	1
piece	(peu importe mark)	false	1	1
4.2 ‚ÄúBloquer √† 1‚Äù (d√©finition exacte)

Quand unit=milliers et markNorm‚â†DZ :

l‚Äôinput passe en mode entier

l‚ÄôUI refuse . et ,

si l‚Äôutilisateur colle/√©crit 0,5 ou 0.5 :

l‚ÄôUI corrige imm√©diatement vers 1

si l‚Äôutilisateur met 0 :

l‚ÄôUI corrige vers 1

‚û°Ô∏è R√©sultat : l‚Äôutilisateur n‚Äôest pas stopp√© par un message, mais il ne peut pas rester sur une valeur ill√©gale.

4.3 Changement de MARK ou unit√© : correction instantan√©e

Exemple :

unit=milliers, mark=DZ, qty=0.5 (OK)

l‚Äôutilisateur change mark ‚Üí PAQUE

allowDecimal devient false

qty doit devenir entier ‚â• 1

UI corrige 0.5 ‚Üí 1 imm√©diatement

5) Validation backend (obligatoire m√™me si l‚ÄôUI est parfaite)

Pourquoi : appels API, bugs UI, valeurs ‚Äúinject√©es‚Äù ou import.

5.1 R√®gles backend √† refaire syst√©matiquement

Si unit === "milliers" et markNorm !== "DZ" :

qty doit √™tre enti√®re

qty ‚â• 1

Si unit === "piece" :

qty enti√®re

qty ‚â• 1

Si unit === "carton" :

qty > 0

d√©cimal autoris√©

6) Vente : transaction SQL locale (le c≈ìur OFFLINE-FIRST)
6.1 Num√©ro facture

G√©n√©rer invoice_no = YYYYMMDDHHmmss (heure locale PC)

G√©n√©rer date_iso = new Date().toISOString()

Toutes les lignes d‚Äôune facture partagent :

le m√™me invoice_no

le m√™me date_iso

6.2 Stock local : r√©duction imm√©diate

√Ä la finalisation :

r√©duire le stock local pour (product_code, unit) :

stock_qty = stock_qty - qty

accepter d√©cimales pour carton et milliers + DZ

refuser d√©cimales pour piece et milliers + non-DZ

6.3 Enregistrement ventes (local)

Chaque ligne doit contenir au minimum :

date_iso

invoice_no

product_code

client

qty

mark_raw + mark_norm

unit

unit_price_fc_final (toujours)

colonnes tel : vides si vente PC

_uuid (unique stable)

_updated_at

_device_id

seller

7) Impression automatique : print_job + watcher @module.js
7.1 √Ä la finalisation : cr√©er un print_job

Cr√©er print_job :

invoice_no

template (ex: 80hbs)

payload_json (facture + lignes + devise active + totaux)

status = pending

attempts = 0

created_at

7.2 Watcher dans @module.js

Toutes les 1‚Äì2 sec :

prendre pending

passer processing

imprimer

si OK : printed

si KO : error, attempts++, next_retry_at

Important :

l‚Äôimpression ne doit jamais bloquer la vente

offline ‚Üí impression OK (si imprimante OK)

8) Sync Google Sheets : queue + worker (batch + retry + idempotence)
8.1 Tout passe par sync_queue

√Ä la finalisation, d√©poser au minimum :

sales_append (append lignes facture dans feuille Ventes)

stock_update (mise √† jour stock dans feuille unit√©)

price_history_append (journal prix effectu√©)

8.2 Batch par facture

Le worker doit regrouper :

par invoice_no

et envoyer un lot coh√©rent

8.3 Retry + backoff intelligent

si pas Internet : ne rien supprimer, garder pending

si erreur Sheets/Script : attempts++ + backoff

ne pas ‚Äúspam‚Äù la m√™me requ√™te en boucle

8.4 Idempotence (anti doublons)

_uuid doit √™tre √©crit dans Sheets

Apps Script doit ignorer une ligne si _uuid existe d√©j√†

sinon retry = doublons

9) Prix / devise : conversion USD‚ÜíFC + respect devise active lors des modifications
9.1 Prix par d√©faut

Si produit a un prix USD :

calculer FC = USD * fx_rate (pour stockage backend)

mais ne pas forcer l‚ÄôUI √† repasser en USD

Si produit a un prix FC :

utiliser FC directement

9.2 Devise active (FC / USD)

Tu gardes activeCurrency c√¥t√© UI :

si activeCurrency = FC :

input prix en FC

si base USD, tu peux afficher conversion en petit, mais pas switch

si activeCurrency = USD :

input prix en USD

9.3 Si l‚Äôutilisateur modifie le prix

si activeCurrency = FC ‚Üí override_price_fc

si activeCurrency = USD ‚Üí override_price_usd

Et tu recalcules :

totals en devise active

stockage backend toujours coh√©rent (FC canonique)

10) Changements attendus dans tes 3 pages
10.1 SalesPOS.jsx

Doit g√©rer par ligne :

unit normalis√©

markNorm

qtyText + qtyValue

qtyPolicy (allowDecimal/min/step)

Doit appliquer en temps r√©el :

milliers + non-DZ ‚áí entier min 1 (bloque d√©cimal + corrige)

milliers + DZ ‚áí d√©cimal autoris√©

carton ‚áí d√©cimal autoris√©

piece ‚áí entier min 1

√Ä Finaliser :

appeler backend finalize

backend fait SQL + cr√©e sync_job + cr√©e print_job

UI affiche OK imm√©diatement m√™me offline

10.2 SalesDetail.jsx

Afficher :

facture + lignes

prix final + devise active au moment de vente

fx_rate_used

statuts :

Sync pending/synced/error

Print pending/printed/error

10.3 SalesHistory.jsx

Lister factures local :

badge Sync ‚è≥/‚úÖ/‚ö†Ô∏è

badge Print ‚è≥/‚úÖ/‚ö†Ô∏è

afficher last_error si besoin (debug sans g√™ner)

11) R√®gle ultra simple (version ‚Äúphrase unique‚Äù)

Si unit = milliers :

si markNorm = DZ ‚Üí d√©cimal autoris√© (0.25 / 0.5 / 0,50 / 1 / 2 / ‚Ä¶)

sinon (PAQUE/BT/PQT/‚Ä¶) ‚Üí d√©cimal interdit, entier obligatoire, min = 1, bloqu√© en temps r√©el

12) Mini check-list de validation (tests rapides)

milliers + DZ + qty 0,50 ‚Üí accept√© ‚Üí stock -0.5

milliers + DZ + qty 0,25 ‚Üí accept√©

milliers + PAQUE + qty 0,5 ‚Üí UI corrige instantan√©ment √† 1

milliers + BT + qty 0 ‚Üí UI corrige √† 1

piece + qty 0,5 ‚Üí UI corrige √† 1

carton + qty 0,25 ‚Üí accept√©

offline total : finaliser vente ‚Üí OK, stock local r√©duit, print_job cr√©√©, sync_queue pending  dans @src/ui/pages/SalesPOS.jsx est @src/ui/pages/SalesDetail.jsx est @src/ui/pages/SalesHistory.jsx est @print/module.js est impresion utilise @print/templates/receipt-80.hbs est comprend une chose tres improtant de ne pas confondre sa ameliore tout soit pusiant il doive genere le numero est tou sera syncronise dans sheets 10. √Ä NE PAS FAIRE (risques majeurs)

‚ùå Ne pas appeler Google Sheets pendant /finalize-sale

‚ùå Ne pas recalculer tout le stock UI apr√®s chaque vente

‚ùå Ne pas faire de sync ligne par ligne (batch only)

‚ùå Ne jamais faire de loop bloquante en Node (event loop bloqu√©e) est sa 1) Noms de feuilles Google Sheets (exactement ceux que tu utilises)
1.1 Feuille des ventes (append)

‚úÖ Nom exact : Ventes

‚û°Ô∏è Chaque ligne d‚Äôarticle vendu (pas une ligne par facture) est ajout√©e dans Ventes.

1.2 Feuilles de stock (update Stock initial)

‚úÖ Noms exacts :

Carton (stock pour unit√© carton)

Milliers (stock pour unit√© milliers)

Piece (stock pour unit√© pi√®ce)

‚û°Ô∏è Quand tu vends un produit dans une unit√© donn√©e, tu mets √† jour le stock dans la feuille correspondante, et tu modifies la colonne Stock initial (ton exemple montre souvent colonne C, mais on ne code pas ‚ÄúC‚Äù en dur : on cherche l‚Äôen-t√™te).

1.3 Feuille ‚Äúprix effectu√©‚Äù (append)

‚úÖ Nom exact : Stock de prix effectu√©

‚û°Ô∏è Apr√®s une vente, tu ajoutes dans cette feuille :

Date

Prix

Numero du produit

Total

Numero de facture

2) Mapping strict : unit√© ‚Üí feuille stock (aucune ambigu√Øt√©)

Dans ton backend worker (sync), la r√®gle est 100% d√©terministe :

unit = "carton" ‚Üí feuille Carton

unit = "milliers" ‚Üí feuille Milliers

unit = "piece" ‚Üí feuille Piece

Et les ventes vont toujours dans Ventes, et le journal prix toujours dans Stock de prix effectu√©.

Tu peux le repr√©senter comme une constante (c√¥t√© backend) :

const SHEETS = {
  SALES: "Ventes",
  PRICE_HISTORY: "Stock de prix effectu√©",
  STOCK_BY_UNIT: {
    carton: "Carton",
    milliers: "Milliers",
    piece: "Piece",
  },
};

3) OFFLINE-FIRST (rappel) + sync arri√®re-plan : avec TES feuilles
3.1 Vente (toujours local SQL)

La vente :

ne d√©pend jamais de Sheets

se valide toujours en SQL local

r√©duit le stock local imm√©diatement

cr√©e des jobs sync_queue (pending)

cr√©e un job print_job (pending)

3.2 Sync Sheets (worker backend)

Le worker lit la queue et pousse vers TES feuilles :

Append dans Ventes

Update stock dans Carton / Milliers / Piece

Append dans Stock de prix effectu√©