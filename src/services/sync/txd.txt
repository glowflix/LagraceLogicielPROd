import { syncRepo } from '../../db/repositories/sync.repo.js';
import { outboxRepo } from '../../db/repositories/outbox.repo.js';
import { sheetsClient } from './sheets.client.js';
import { productsRepo } from '../../db/repositories/products.repo.js';
import { salesRepo } from '../../db/repositories/sales.repo.js';
import { debtsRepo } from '../../db/repositories/debts.repo.js';
import { ratesRepo } from '../../db/repositories/rates.repo.js';
import { usersRepo } from '../../db/repositories/users.repo.js';
import { syncLogger } from '../../core/logger.js';
import { generateUUID } from '../../core/crypto.js';
import { getDb } from '../../db/sqlite.js';
import bcrypt from 'bcrypt';

// Intervalle de synchronisation (augment√© pour r√©duire la charge)
const SYNC_INTERVAL_MS = parseInt(process.env.SYNC_INTERVAL_MS) || 10000; // 10 secondes par d√©faut

let syncInterval = null;
let isSyncing = false;
let syncRunning = false; // Mutex global pour emp√™cher les overlaps
let _started = false; // Flag pour la boucle "apr√®s fin"
let _loopTimeout = null; // Timeout de la boucle
let isOnline = true; // √âtat de connexion Internet
let _salesSyncRunning = false; // Mutex pour la synchronisation des ventes
let _salesLoopTimeout = null; // Timeout de la boucle de synchronisation des ventes
let _pushSyncRunning = false; // Mutex pour le push des op√©rations pending
let _lastPushTime = 0; // Dernier push r√©ussi

/**
 * Normalise l'unit√© depuis Sheets vers le format SQLite
 * Sheets peut avoir: "millier", "carton", "piece" (ou variations)
 * SQLite attend: "MILLIER", "CARTON", "PIECE" ou 1, 2, 3
 */
function normalizeUnitFromSheets(unitValue) {
  if (!unitValue || typeof unitValue !== 'string') return null;
  
  const trimmed = unitValue.trim();
  if (!trimmed) return null;
  
  const normalized = trimmed.toLowerCase();
  
  // Mapping des valeurs possibles depuis Sheets (ordre important : millier avant carton pour √©viter les faux positifs)
  // G√©rer "milliers" (pluriel) et "millier" (singulier)
  if (normalized === 'millier' || normalized === 'milliers' || normalized.includes('millier')) {
    return 'MILLIER';
  }
  // G√©rer "carton" et "cartons"
  if (normalized === 'carton' || normalized === 'cartons' || normalized.includes('carton')) {
    return 'CARTON';
  }
  // G√©rer "piece", "pi√®ce", "pieces", "pi√®ces"
  if (normalized === 'piece' || normalized === 'pi√®ce' || normalized === 'pieces' || normalized === 'pi√®ces' || normalized.includes('piece') || normalized.includes('pi√®ce')) {
    return 'PIECE';
  }
  
  // Si c'est d√©j√† en majuscules, le retourner tel quel
  const upper = trimmed.toUpperCase();
  if (upper === 'MILLIER' || upper === 'MILLIERS' || upper === 'CARTON' || upper === 'CARTONS' || upper === 'PIECE' || upper === 'PIECES' || upper === 'PI√àCE' || upper === 'PI√àCES') {
    // Normaliser les pluriels en singulier
    if (upper === 'MILLIERS') return 'MILLIER';
    if (upper === 'CARTONS') return 'CARTON';
    if (upper === 'PIECES' || upper === 'PI√àCES') return 'PIECE';
    return upper;
  }
  
  // Valeur non reconnue, retourner null pour forcer la recherche dans le produit
  return null;
}

/**
 * Worker de synchronisation qui tourne en arri√®re-plan
 */
export class SyncWorker {
  /**
   * D√©marre le worker avec import initial intelligent
   */
  async start() {
    if (syncInterval) {
      return; // D√©j√† d√©marr√©
    }

    syncLogger.info(`üöÄ D√©marrage du worker de synchronisation (intervalle: ${SYNC_INTERVAL_MS}ms)`);
    syncLogger.info(`üì° URL Google Apps Script: ${process.env.GOOGLE_SHEETS_WEBAPP_URL ? '‚úÖ Configur√©e' : '‚ùå Non configur√©e'}`);

    // D√©tection automatique de connexion (doit √™tre fait en premier)
    this.setupConnectionDetection();

    // V√©rifier si l'import initial a d√©j√† √©t√© fait
    const initialImportDone = syncRepo.isInitialImportDone();
    const isDatabaseEmpty = !productsRepo.hasProducts();
    
    // BOOTSTRAP AUTOMATIQUE : Si table vide ‚Üí full pull (m√™me si flag = 1)
    if (isDatabaseEmpty) {
      syncLogger.warn('‚ö†Ô∏è  [BOOTSTRAP] Base de donn√©es vide (0 produits) ‚Üí Bootstrap automatique activ√©');
      syncLogger.info('   üîÑ [BOOTSTRAP] Mode: Full pull (toutes les donn√©es) m√™me si initial_import_done = 1');
      syncLogger.info('   üìã [BOOTSTRAP] Le syst√®me va t√©l√©charger TOUTES les donn√©es existantes dans Google Sheets');
      
      // V√©rifier la connexion d'abord
      await this.checkConnection();
      
      // Si en ligne, faire le bootstrap imm√©diatement
      if (isOnline) {
        syncLogger.info('   üöÄ [BOOTSTRAP] D√©marrage du bootstrap (full pull)...');
        this.pullUpdates(true).catch(err => {
          syncLogger.error('‚ùå [BOOTSTRAP] Erreur lors du bootstrap:', err);
          syncLogger.warn('   ‚ö†Ô∏è  [BOOTSTRAP] Bootstrap √©chou√©, sera r√©essay√© au prochain cycle si base toujours vide');
        });
      } else {
        syncLogger.info('‚è≥ [BOOTSTRAP] En attente de connexion Internet pour le bootstrap...');
      }
    } else if (!initialImportDone) {
      // Import initial classique (si flag = 0 mais base non vide, c'est suspect mais on continue)
      syncLogger.info('üì• [IMPORT] Flag initial_import_done = 0, mais base contient des donn√©es');
      syncLogger.info('   üîÑ [IMPORT] Synchronisation incr√©mentale normale');
      if (isOnline) {
        await this.runSyncSafe();
      }
    } else {
      // Mode normal : base non vide + flag = 1
      syncLogger.info('üìä [SYNC] Mode normal : synchronisation incr√©mentale uniquement');
      if (isOnline) {
        await this.runSyncSafe();
      }
    }

    // Boucle "apr√®s fin" au lieu de setInterval (√©vite les overlaps)
    syncLogger.info(`‚è∞ [AUTO-SYNC] Synchronisation automatique configur√©e: toutes les ${SYNC_INTERVAL_MS / 1000} secondes (TEMPS R√âEL)`);
    syncLogger.info(`   üîÑ [AUTO-SYNC] Mode: D√©tection Internet auto + Sync auto toutes les ${SYNC_INTERVAL_MS / 1000}s`);
    syncLogger.info(`   üìä [AUTO-SYNC] Les donn√©es seront stock√©es dans SQL et disponibles imm√©diatement dans les pages`);
    syncLogger.info(`   ‚ö° [AUTO-SYNC] Mode PRO: Boucle "apr√®s fin" (pas de setInterval) pour √©viter les overlaps`);
    
    _started = true;
    const loop = async () => {
      if (!_started) return;
      
      // Utiliser setImmediate pour diff√©rer la sync et ne pas bloquer l'event loop
      setImmediate(async () => {
        const t0 = Date.now();
        if (isOnline) {
          // Utiliser process.nextTick pour donner la priorit√© aux requ√™tes API
          process.nextTick(async () => {
            await this.runSyncSafe().catch(err => {
              syncLogger.error(`‚ùå [AUTO-SYNC] Erreur sync automatique: ${err.message}`);
            });
          });
        } else {
          syncLogger.debug(`‚è∏Ô∏è  [AUTO-SYNC] Sync ignor√©e: pas de connexion Internet`);
        }
        
        const elapsed = Date.now() - t0;
        const wait = Math.max(2000, SYNC_INTERVAL_MS - elapsed); // min 2s (au lieu de 1s)
        
        if (_started) {
          _loopTimeout = setTimeout(loop, wait);
        }
      });
    };
    
    // D√©marrer la boucle avec un d√©lai initial pour ne pas bloquer le d√©marrage
    setTimeout(loop, 5000); // Attendre 5s avant la premi√®re sync
    
    // D√©marrer la synchronisation d√©di√©e des ventes (imm√©diate + toutes les 10 secondes)
    this.startSalesSyncLoop();
    
    // D√©marrer la synchronisation des op√©rations pending (push vers Sheets)
    // IMPORTANT: Les modifications locales (prix, stock, etc.) sont push√©es automatiquement
    this.startPushSyncLoop();
  }
  
  /**
   * Boucle de push des op√©rations pending vers Google Sheets
   * G√®re automatiquement les modifications locales quand la connexion revient
   * 
   * Fonctionnalit√©s:
   * - Push automatique des PRODUCT_PATCH (modifications prix/nom)
   * - Push automatique des UNIT_PATCH (modifications unit√©s)
   * - Push automatique des STOCK_MOVE (mouvements de stock)
   * - D√©duplication automatique (last-write-wins pour les patches)
   * - Idempotence via op_id (pas de doublons c√¥t√© Sheets)
   */
  async startPushSyncLoop() {
    const PUSH_SYNC_INTERVAL_MS = 15000; // 15 secondes
    
    syncLogger.info(`üì§ [PUSH-SYNC] D√©marrage de la synchronisation des modifications locales`);
    syncLogger.info(`   ‚ö° [PUSH-SYNC] Mode: AUTO-PUSH toutes les ${PUSH_SYNC_INTERVAL_MS / 1000} secondes`);
    syncLogger.info(`   üì¶ [PUSH-SYNC] Types: PRODUCT_PATCH, UNIT_PATCH, STOCK_MOVE`);
    syncLogger.info(`   üîÑ [PUSH-SYNC] Idempotence via op_id (pas de doublons)`);
    
    const pushLoop = async () => {
      if (!_started) return;
      
      if (_pushSyncRunning) {
        syncLogger.debug(`‚è≠Ô∏è [PUSH-SYNC] Push d√©j√† en cours, skip`);
        setTimeout(pushLoop, PUSH_SYNC_INTERVAL_MS);
        return;
      }
      
      if (!isOnline) {
        syncLogger.debug(`‚è∏Ô∏è [PUSH-SYNC] Pas de connexion Internet, op√©rations en attente`);
        // Afficher le nombre d'op√©rations en attente
        try {
          const stats = outboxRepo.getStats();
          if (stats.totalPending > 0) {
            syncLogger.info(`   üìä [PUSH-SYNC] ${stats.totalPending} op√©ration(s) en attente de connexion`);
          }
        } catch (e) {}
        setTimeout(pushLoop, PUSH_SYNC_INTERVAL_MS);
        return;
      }
      
      _pushSyncRunning = true;
      const pushStartTime = Date.now();
      
      try {
        await this.pushPendingOperations();
      } catch (error) {
        syncLogger.error(`‚ùå [PUSH-SYNC] Erreur lors du push: ${error.message}`);
      } finally {
        _pushSyncRunning = false;
        const elapsed = Date.now() - pushStartTime;
        const wait = Math.max(5000, PUSH_SYNC_INTERVAL_MS - elapsed);
        
        if (_started) {
          setTimeout(pushLoop, wait);
        }
      }
    };
    
    // D√©marrer apr√®s un d√©lai initial (laisser le temps au pull de se faire d'abord)
    setTimeout(pushLoop, 10000);
  }
  
  /**
   * Push les op√©rations pending vers Google Sheets
   * G√®re les patches produits, patches unit√©s et mouvements de stock
   */
  async pushPendingOperations() {
    try {
      // R√©cup√©rer les statistiques
      const stats = outboxRepo.getStats();
      
      if (stats.totalPending === 0 && stats.stockMovesPending === 0) {
        syncLogger.debug(`üì§ [PUSH-SYNC] Aucune op√©ration pending`);
        return;
      }
      
      syncLogger.info(`üì§ [PUSH-SYNC] ==========================================`);
      syncLogger.info(`üì§ [PUSH-SYNC] PUSH DES MODIFICATIONS LOCALES`);
      syncLogger.info(`üì§ [PUSH-SYNC] ==========================================`);
      syncLogger.info(`   üìä Pending: ${JSON.stringify(stats.pendingByType)}`);
      syncLogger.info(`   üìä Stock moves pending: ${stats.stockMovesPending}`);
      
      // 1. Push des patches produits (PRODUCT_PATCH)
      const productPatches = outboxRepo.getPendingOperations('PRODUCT_PATCH', 50);
      if (productPatches.length > 0) {
        syncLogger.info(`   üì¶ [PRODUCT_PATCH] ${productPatches.length} patch(es) √† envoyer`);
        await this.pushProductPatches(productPatches);
      }
      
      // 2. Push des patches unit√©s (UNIT_PATCH) - inclut les prix
      const unitPatches = outboxRepo.getPendingOperations('UNIT_PATCH', 50);
      if (unitPatches.length > 0) {
        syncLogger.info(`   üí∞ [UNIT_PATCH] ${unitPatches.length} patch(es) √† envoyer (prix, etc.)`);
        await this.pushUnitPatches(unitPatches);
      }
      
      // 3. Push des mouvements de stock (STOCK_MOVE)
      const stockMoves = outboxRepo.getPendingOperations('STOCK_MOVE', 50);
      if (stockMoves.length > 0) {
        syncLogger.info(`   üìä [STOCK_MOVE] ${stockMoves.length} mouvement(s) √† envoyer`);
        await this.pushStockMoves(stockMoves);
      }
      
      // R√©essayer les op√©rations en erreur (max 3 tentatives)
      outboxRepo.retryErrorOperations();
      
      _lastPushTime = Date.now();
      
      // CRITIQUE: Apr√®s un push r√©ussi, d√©clencher un pull pour recevoir les mises √† jour depuis Sheets
      // Cela lib√®re les produits pour accepter les modifications venant de Sheets
      const pushedCount = (productPatches.length || 0) + (unitPatches.length || 0) + (stockMoves.length || 0);
      if (pushedCount > 0) {
        syncLogger.info(`   üîÑ [PUSH-SYNC] ${pushedCount} op√©ration(s) envoy√©e(s), d√©clenchement pull pour recevoir les mises √† jour depuis Sheets...`);
        
        // D√©clencher un pull apr√®s un court d√©lai pour laisser Sheets se mettre √† jour
        // CRITIQUE: Cela lib√®re les produits pour recevoir les mises √† jour depuis Sheets
        setTimeout(async () => {
          try {
            syncLogger.info(`   üì• [PUSH-SYNC] Pull d√©clench√© apr√®s push r√©ussi pour lib√©rer les produits`);
            await this.syncProductsFromSheets();
          } catch (pullError) {
            syncLogger.warn(`   ‚ö†Ô∏è [PUSH-SYNC] Erreur pull apr√®s push: ${pullError.message}`);
          }
        }, 2000); // 2 secondes de d√©lai pour laisser Sheets se mettre √† jour
      }
      
      syncLogger.info(`üì§ [PUSH-SYNC] ==========================================`);
      
    } catch (error) {
      syncLogger.error(`‚ùå [PUSH-SYNC] Erreur pushPendingOperations: ${error.message}`);
    }
  }
  
  /**
   * Push les patches produits vers Sheets
   * Utilise batchPush pour √™tre compatible avec le Code.gs (handleBatchPush)
   * CRITIQUE: S'assurer que le champ 'name' et 'unit_level' sont TOUJOURS inclus
   */
  async pushProductPatches(patches) {
    if (!patches || patches.length === 0) return;
    
    const ackedOpIds = [];
    
    // Pr√©parer les op√©rations pour batchPush
    const ops = patches.map((op, idx) => {
      // CRITIQUE: Utiliser op.payload_json (pas op.payload!) car les donn√©es en DB sont stock√©es comme JSON string
      let payloadData = {};
      if (op.payload_json) {
        if (typeof op.payload_json === 'string') {
          try {
            payloadData = JSON.parse(op.payload_json);
          } catch (e) {
            syncLogger.warn(`      ‚ö†Ô∏è [PRODUCT ${idx}] Impossible de parser payload_json pour ${op.entity_code}: ${e.message}`);
            payloadData = {};
          }
        } else {
          payloadData = op.payload_json;
        }
      }
      
      // CRITIQUE: Le champ 'name' DOIT √™tre pr√©sent dans le payload
      // Si absent, utiliser string vide (jamais undefined ou null)
      const finalName = payloadData.name !== undefined && payloadData.name !== null 
        ? String(payloadData.name) 
        : '';
      
      // CRITIQUE: R√©cup√©rer le produit complet pour obtenir unit_level et uuid
      // Sans unit_level, Google Apps Script ne peut pas router vers la bonne feuille
      let unitLevel = payloadData.unit_level || 'CARTON';  // D√©faut: CARTON
      let uuid = payloadData.uuid || op.entity_uuid || '';  // UUID du produit pour suivi
      try {
        const fullProduct = productsRepo.findByCode(op.entity_code);
        if (fullProduct) {
          // R√©cup√©rer l'UUID du produit
          uuid = fullProduct.uuid || uuid;
          
          // R√©cup√©rer le unit_level du premier produit de ce code
          if (fullProduct.units && fullProduct.units.length > 0) {
            unitLevel = fullProduct.units[0].unit_level || 'CARTON';
          }
        }
      } catch (e) {
        syncLogger.debug(`      ‚ÑπÔ∏è [PRODUCT ${idx}] Impossible de r√©cup√©rer donn√©es compl√®tes, utilisation d√©faut: CARTON`);
      }
      
      const operationPayload = {
        code: op.entity_code,
        name: finalName,
        is_active: payloadData.is_active !== undefined ? payloadData.is_active : 1,
        unit_level: unitLevel,  // CRITIQUE: Ajout√© pour que Google Apps Script sache quelle feuille utiliser
        uuid: uuid,  // CRITIQUE: Ajout√© pour tracking du produit (colonne _uuid in Sheets)
        ...payloadData  // Spread pour inclure tous les autres champs
      };
      
      // LOG D√âTAILL√â pour debug
      if (idx < 3) {
        syncLogger.info(`      üì¶ [PRODUCT ${idx}] Code='${op.entity_code}', Name='${finalName}' (length=${finalName.length}), unit_level='${unitLevel}', is_active=${operationPayload.is_active}`);
      }
      
      return {
        op_id: op.op_id,
        entity: 'products',
        op: 'upsert',
        payload: operationPayload
      };
    });
    
    if (ops.length > 3) {
      syncLogger.info(`         ... et ${ops.length - 3} autre(s) produit(s)`);
    }
    
    try {
      syncLogger.info(`      üì§ Push ${patches.length} patch(es) produit vers Sheets via batchPush`);
      
      // Utiliser pushBatch qui supporte le mode batch via Code.gs
      const result = await sheetsClient.pushBatch(ops);
      
      if (result.success) {
        // Marquer les op√©rations appliqu√©es comme confirm√©es
        for (const applied of (result.applied || [])) {
          if (applied.op_id) {
            ackedOpIds.push(applied.op_id);
          }
        }
        
        // Marquer les conflits comme erreurs
        for (const conflict of (result.conflicts || [])) {
          if (conflict.op_id) {
            outboxRepo.markAsError(conflict.op_id, conflict.reason || 'Conflit');
            syncLogger.warn(`      ‚ö†Ô∏è Conflit produit (op_id: ${conflict.op_id}): ${conflict.reason}`);
          }
        }
        
        syncLogger.info(`      ‚úÖ ${ackedOpIds.length}/${patches.length} patch(es) produit confirm√©(s) dans Sheets`);
      } else {
        for (const op of patches) {
          outboxRepo.markAsError(op.op_id, result.error || 'Erreur push');
        }
        syncLogger.warn(`      ‚ö†Ô∏è Erreur patches produits: ${result.error}`);
      }
    } catch (error) {
      for (const op of patches) {
        outboxRepo.markAsError(op.op_id, error.message);
      }
      syncLogger.error(`      ‚ùå Erreur push produits: ${error.message}`);
    }
    
    if (ackedOpIds.length > 0) {
      outboxRepo.markAsAcked(ackedOpIds);
    }
  }
  
  /**
   * Push les patches unit√©s vers Sheets (prix, stock, etc.)
   * CRITIQUE: Inclut sale_price_fc et stock_current pour TOUTES les unit√©s (CARTON, MILLIER, PIECE)
   * Utilise batchPush pour √™tre compatible avec le Code.gs (handleBatchPush ‚Üí handleProductUpsert)
   */
  async pushUnitPatches(patches) {
    if (!patches || patches.length === 0) return;
    
    const ackedOpIds = [];
    
    // Pr√©parer les op√©rations pour batchPush
    // IMPORTANT: Chaque patch d'unit√© doit inclure:
    // - code (product_code)
    // - unit_level (CARTON, MILLIER, PIECE)
    // - sale_price_fc (pour TOUTES les feuilles: Carton, Milliers, Piece)
    // - sale_price_usd
    // - stock_current/stock_initial
    // - auto_stock_factor
    const ops = patches.map(op => {
      const payload = op.payload || {};
      
      // CRITIQUE: Construire le payload complet pour handleProductUpsert dans Code.gs
      return {
        op_id: op.op_id,
        entity: 'product_units',
        op: 'upsert',
        payload: {
          code: payload.product_code || op.entity_code,
          name: payload.name || '',
          unit_level: payload.unit_level,
          unit_mark: payload.unit_mark || '',
          // CRITIQUE: Inclure les deux prix pour Sheets
          sale_price_usd: payload.sale_price_usd || 0,
          sale_price_fc: payload.sale_price_fc || 0,
          purchase_price_usd: payload.purchase_price_usd || 0,
          // CRITIQUE: Inclure le stock
          stock_initial: payload.stock_initial || payload.stock_current || 0,
          stock_current: payload.stock_current || payload.stock_initial || 0,
          // Automatisation stock
          auto_stock_factor: payload.auto_stock_factor || 1,
          qty_step: payload.qty_step || 1,
          // M√©tadonn√©es
          uuid: payload.product_uuid,
          last_update: new Date().toISOString()
        }
      };
    });
    
    try {
      syncLogger.info(`      üì§ Push ${patches.length} patch(es) unit√© via batchPush`);
      
      // Log d√©taill√© pour debug
      for (const op of ops.slice(0, 3)) {
        syncLogger.info(`         üì¶ ${op.payload.code}/${op.payload.unit_level}: FC=${op.payload.sale_price_fc}, USD=${op.payload.sale_price_usd}, Stock=${op.payload.stock_current}`);
      }
      if (ops.length > 3) {
        syncLogger.info(`         ... et ${ops.length - 3} autre(s)`);
      }
      
      // Utiliser pushBatch qui supporte le mode batch via Code.gs
      const result = await sheetsClient.pushBatch(ops);
      
      if (result.success) {
        // Marquer les op√©rations appliqu√©es comme confirm√©es
        for (const applied of (result.applied || [])) {
          if (applied.op_id) {
            ackedOpIds.push(applied.op_id);
          }
        }
        
        // Marquer les conflits comme erreurs
        for (const conflict of (result.conflicts || [])) {
          if (conflict.op_id) {
            outboxRepo.markAsError(conflict.op_id, conflict.reason || 'Conflit');
            syncLogger.warn(`         ‚ö†Ô∏è Conflit unit√© (op_id: ${conflict.op_id}): ${conflict.reason}`);
          }
        }
        
        syncLogger.info(`      ‚úÖ ${ackedOpIds.length}/${patches.length} patch(es) unit√© confirm√©(s)`);
      } else {
        for (const op of patches) {
          outboxRepo.markAsError(op.op_id, result.error || 'Erreur push');
        }
        syncLogger.warn(`      ‚ö†Ô∏è Erreur patches unit√©s: ${result.error}`);
      }
    } catch (error) {
      for (const op of patches) {
        outboxRepo.markAsError(op.op_id, error.message);
      }
      syncLogger.error(`      ‚ùå Erreur push unit√©s: ${error.message}`);
    }
    
    if (ackedOpIds.length > 0) {
      outboxRepo.markAsAcked(ackedOpIds);
    }
  }
  
  /**
   * Push les mouvements de stock vers Sheets
   * IMPORTANT: On envoie des DELTAS, pas des valeurs absolues
   */
  async pushStockMoves(moves) {
    const ackedOpIds = [];
    const ackedMoveIds = [];
    
    // Grouper par produit/unit√© pour batch
    const movesByUnit = {};
    for (const op of moves) {
      const payload = op.payload;
      const key = `${payload.product_code}-${payload.unit_level}-${payload.unit_mark || ''}`;
      if (!movesByUnit[key]) {
        movesByUnit[key] = {
          product_code: payload.product_code,
          unit_level: payload.unit_level,
          unit_mark: payload.unit_mark || '',
          moves: []
        };
      }
      movesByUnit[key].moves.push({ op, payload });
    }
    
    for (const key in movesByUnit) {
      const unitMoves = movesByUnit[key];
      
      try {
        // Calculer le delta total pour cette unit√©
        const totalDelta = unitMoves.moves.reduce((sum, m) => sum + m.payload.delta, 0);
        
        syncLogger.info(`      üì§ Push mouvement stock: ${unitMoves.product_code}/${unitMoves.unit_level} delta=${totalDelta > 0 ? '+' : ''}${totalDelta}`);
        
        // Pr√©parer les donn√©es pour Sheets
        const moveData = {
          product_code: unitMoves.product_code,
          unit_level: unitMoves.unit_level,
          unit_mark: unitMoves.unit_mark,
          delta: totalDelta,
          move_ids: unitMoves.moves.map(m => m.payload.move_id),
          op_ids: unitMoves.moves.map(m => m.op.op_id)
        };
        
        // Appeler l'API Sheets pour appliquer le delta de stock
        const result = await sheetsClient.push('stock_moves', [moveData]);
        
        if (result.success) {
          for (const m of unitMoves.moves) {
            ackedOpIds.push(m.op.op_id);
            if (m.payload.move_id) {
              ackedMoveIds.push(m.payload.move_id);
            }
          }
          syncLogger.info(`      ‚úÖ Mouvement stock confirm√©: ${unitMoves.product_code}/${unitMoves.unit_level}`);
        } else {
          for (const m of unitMoves.moves) {
            outboxRepo.markAsError(m.op.op_id, result.error || 'Erreur push');
          }
          syncLogger.warn(`      ‚ö†Ô∏è Erreur mouvement stock: ${result.error}`);
        }
      } catch (error) {
        for (const m of unitMoves.moves) {
          outboxRepo.markAsError(m.op.op_id, error.message);
        }
        syncLogger.error(`      ‚ùå Erreur push stock ${key}: ${error.message}`);
      }
    }
    
    if (ackedOpIds.length > 0) {
      outboxRepo.markAsAcked(ackedOpIds);
    }
    if (ackedMoveIds.length > 0) {
      outboxRepo.markStockMovesSynced(ackedMoveIds);
    }
  }
  
  /**
   * Synchronise uniquement les produits depuis Sheets (pull)
   * Utilis√© apr√®s un push r√©ussi pour lib√©rer les produits et recevoir les mises √† jour depuis Sheets
   * CRITIQUE: Les produits avec des op√©rations "acked" ne sont plus bloqu√©s et peuvent recevoir les mises √† jour
   */
  async syncProductsFromSheets() {
    try {
      syncLogger.info(`üì• [PRODUCTS-PULL] Synchronisation produits depuis Sheets (apr√®s push r√©ussi)`);
      
      // R√©cup√©rer la date de derni√®re synchronisation
      const sinceDate = syncRepo.getLastPullDate('products');
      const since = sinceDate ? new Date(sinceDate) : new Date(0);
      
      // Pull pagin√© par unit_level (CARTON, MILLIER, PIECE)
      const productUnitLevels = ['CARTON', 'MILLIER', 'PIECE'];
      const allProducts = [];
      
      for (const unitLevel of productUnitLevels) {
        try {
          syncLogger.info(`   üìÑ [PRODUCTS-PULL] Feuille: ${unitLevel}`);
          
          const result = await sheetsClient.pullAllPaged('products', since, {
            full: false, // Mode incr√©mental seulement
            unitLevel: unitLevel,
            maxRetries: 3,
            timeout: 30000,
            limit: 300
          });
          
          if (result.success && result.data.length > 0) {
            allProducts.push(...result.data);
            syncLogger.info(`   ‚úÖ [PRODUCTS-PULL/${unitLevel}] ${result.data.length} produit(s) r√©cup√©r√©(s)`);
          } else if (result.success) {
            syncLogger.debug(`   üì≠ [PRODUCTS-PULL/${unitLevel}] Aucune mise √† jour`);
          } else {
            syncLogger.warn(`   ‚ö†Ô∏è [PRODUCTS-PULL/${unitLevel}] Erreur: ${result.error}`);
          }
        } catch (error) {
          syncLogger.error(`   ‚ùå [PRODUCTS-PULL/${unitLevel}] Erreur: ${error.message}`);
        }
      }
      
      // Appliquer les mises √† jour si des produits ont √©t√© r√©cup√©r√©s
      if (allProducts.length > 0) {
        syncLogger.info(`   üì¶ [PRODUCTS-PULL] Total: ${allProducts.length} produit(s) √† appliquer`);
        await this.applyProductUpdates(allProducts);
        syncRepo.setLastPullDate('products', new Date().toISOString());
        syncLogger.info(`   ‚úÖ [PRODUCTS-PULL] Synchronisation termin√©e: ${allProducts.length} produit(s) mis √† jour`);
      } else {
        syncLogger.info(`   ‚úÖ [PRODUCTS-PULL] Aucune mise √† jour disponible depuis Sheets`);
      }
    } catch (error) {
      syncLogger.error(`   ‚ùå [PRODUCTS-PULL] Erreur synchronisation produits: ${error.message}`);
      throw error;
    }
  }
  
  /**
   * Synchronisation d√©di√©e des ventes : Imm√©diate + toutes les 10 secondes
   * Utilise la pagination avec cursor pour prendre beaucoup de donn√©es en lot
   */
  async startSalesSyncLoop() {
    const SALES_SYNC_INTERVAL_MS = 10000; // 10 secondes
    
    syncLogger.info(`üí∞ [SALES-SYNC] D√©marrage de la synchronisation d√©di√©e des ventes`);
    syncLogger.info(`   ‚ö° [SALES-SYNC] Mode: IMM√âDIAT + toutes les ${SALES_SYNC_INTERVAL_MS / 1000} secondes`);
    syncLogger.info(`   üì¶ [SALES-SYNC] Pagination avec cursor pour lots importants`);
    syncLogger.info(`   üîÑ [SALES-SYNC] Continue proprement l√† o√π on s'est arr√™t√©`);
    
    // Fonction de synchronisation des ventes
    const syncSalesLoop = async () => {
      if (!_started) return; // Arr√™ter si le worker est arr√™t√©
      
      if (_salesSyncRunning) {
        syncLogger.debug(`‚è≠Ô∏è [SALES-SYNC] Sync ventes d√©j√† en cours, skip`);
        _salesLoopTimeout = setTimeout(syncSalesLoop, SALES_SYNC_INTERVAL_MS);
        return;
      }
      
      if (!isOnline) {
        syncLogger.debug(`‚è∏Ô∏è [SALES-SYNC] Pas de connexion Internet, skip`);
        _salesLoopTimeout = setTimeout(syncSalesLoop, SALES_SYNC_INTERVAL_MS);
        return;
      }
      
      _salesSyncRunning = true;
      const syncStartTime = Date.now();
      
      try {
        await this.syncSalesOnly();
      } catch (error) {
        syncLogger.error(`‚ùå [SALES-SYNC] Erreur lors de la synchronisation des ventes: ${error.message}`);
      } finally {
        _salesSyncRunning = false;
        const elapsed = Date.now() - syncStartTime;
        const wait = Math.max(1000, SALES_SYNC_INTERVAL_MS - elapsed); // Min 1s entre les syncs
        
        if (_started) {
          _salesLoopTimeout = setTimeout(syncSalesLoop, wait);
        }
      }
    };
    
    // D√©marrer imm√©diatement (pas d'attente)
    setImmediate(() => {
      syncSalesLoop();
    });
  }
  
  /**
   * Synchronise uniquement les ventes depuis Google Sheets avec pagination
   * Utilise pullAllPaged avec cursor pour continuer l√† o√π on s'est arr√™t√©
   */
  async syncSalesOnly() {
    const salesStartTime = Date.now();
    
    try {
      syncLogger.info(`üí∞ [SALES-SYNC] ==========================================`);
      syncLogger.info(`üí∞ [SALES-SYNC] D√âBUT SYNCHRONISATION DES VENTES`);
      syncLogger.info(`üí∞ [SALES-SYNC] ==========================================`);
      
      // R√©cup√©rer le cursor pour continuer l√† o√π on s'est arr√™t√© (import initial en cours)
      const cursor = syncRepo.getCursor('sales');
      
      // D√âTERMINER LE MODE DE SYNCHRONISATION
      let sinceDate;
      let syncMode;
      let isIncrementalSync = false;
      
      if (cursor) {
        // Cursor existe = Import initial en cours (pagination)
        syncMode = 'IMPORT INITIAL (pagination en cours)';
        sinceDate = new Date(0).toISOString(); // T√©l√©charger toutes les ventes
        const cursorStr = String(cursor);
        syncLogger.info(`   üìç [SALES-SYNC] Cursor trouv√©: continuation de la pagination`);
        syncLogger.info(`   üìç [SALES-SYNC] Cursor: ${cursorStr.length > 50 ? cursorStr.substring(0, 50) + '...' : cursorStr}`);
      } else {
        // Pas de cursor = Synchronisation incr√©mentale ou import initial
        const lastPullDate = syncRepo.getLastPullDate('sales');
        
        if (lastPullDate) {
          // Synchronisation incr√©mentale : seulement les ventes modifi√©es/ajout√©es depuis lastPullDate
          // IMPORTANT: Utiliser une date l√©g√®rement ant√©rieure pour √©viter de manquer des ventes
          // (√† cause des diff√©rences de temps entre serveurs ou des arrondis)
          const adjustedDate = new Date(lastPullDate.getTime() - 60000); // Soustraire 1 minute pour s√©curit√©
          syncMode = 'SYNC INCR√âMENTALE (mises √† jour seulement)';
          sinceDate = adjustedDate.toISOString();
          isIncrementalSync = true;
          syncLogger.info(`   üîÑ [SALES-SYNC] Mode: ${syncMode}`);
          syncLogger.info(`   üìÖ [SALES-SYNC] Derni√®re sync: ${lastPullDate.toISOString()} (${lastPullDate.toLocaleString('fr-FR')})`);
          syncLogger.info(`   üìÖ [SALES-SYNC] Date ajust√©e (s√©curit√© -1min): ${sinceDate} (${new Date(sinceDate).toLocaleString('fr-FR')})`);
          syncLogger.info(`   üì• [SALES-SYNC] T√©l√©chargement des ventes modifi√©es/ajout√©es depuis cette date`);
        } else {
          // Pas de lastPullDate = Import initial complet
          syncMode = 'IMPORT INITIAL (premi√®re synchronisation)';
          sinceDate = new Date(0).toISOString();
          syncLogger.info(`   üöÄ [SALES-SYNC] Mode: ${syncMode}`);
          syncLogger.info(`   üì• [SALES-SYNC] T√©l√©chargement de TOUTES les ventes depuis Sheets`);
        }
      }
      
      syncLogger.info(`   üìÖ [SALES-SYNC] Date 'since': ${sinceDate} (${new Date(sinceDate).toLocaleString('fr-FR')})`);
      
      // V√©rification AVANT t√©l√©chargement
      let salesCountBefore = 0;
      let itemsCountBefore = 0;
      try {
        const { getDb } = await import('../../db/sqlite.js');
        const db = getDb();
        const salesCountResult = db.prepare('SELECT COUNT(*) as count FROM sales WHERE origin = ?').get('SHEETS');
        const itemsCountResult = db.prepare('SELECT COUNT(*) as count FROM sale_items').get();
        salesCountBefore = salesCountResult?.count || 0;
        itemsCountBefore = itemsCountResult?.count || 0;
        syncLogger.info(`   üîç [SALES-SYNC] √âTAT AVANT: ${salesCountBefore} vente(s), ${itemsCountBefore} item(s) dans SQLite`);
      } catch (initError) {
        syncLogger.warn(`   ‚ö†Ô∏è  [SALES-SYNC] Erreur v√©rification avant: ${initError.message}`);
      }
      
      // Pull avec pagination PRO
      if (isIncrementalSync) {
        syncLogger.info(`   üì• [SALES-SYNC] Mode INCR√âMENTAL: T√©l√©chargement des ventes modifi√©es/ajout√©es depuis ${new Date(sinceDate).toLocaleString('fr-FR')}...`);
      } else {
        syncLogger.info(`   üì• [SALES-SYNC] Mode IMPORT COMPLET: T√©l√©chargement depuis Google Sheets (mode PRO - continuera jusqu'√† la fin)...`);
      }
      
      let currentCursor = cursor;
      let totalProcessed = 0;
      let pageNumber = 0;
      let isComplete = false;
      let maxUpdatedAt = null; // Pour suivre la date de mise √† jour la plus r√©cente
      
      // BOUCLE jusqu'√† ce que toutes les pages soient lues
      while (!isComplete) {
        pageNumber++;
        syncLogger.info(`   üìÑ [SALES-SYNC] Page ${pageNumber} - Cursor: ${currentCursor || 'd√©but'}`);
        
        // Utiliser pull() pour r√©cup√©rer une seule page √† la fois
        // IMPORTANT: Toujours utiliser full=true pour s'assurer de r√©cup√©rer toutes les ventes
        // m√™me en mode incr√©mental, car Google Sheets filtre d√©j√† par _updated_at
        const result = await sheetsClient.pull('sales', sinceDate, {
          full: true, // Toujours true - Google Sheets filtre par _updated_at automatiquement
          cursor: currentCursor,
          maxRetries: 5,
          timeout: isIncrementalSync ? 30000 : 60000, // Timeout plus court pour sync incr√©mentale (moins de donn√©es)
          limit: isIncrementalSync ? 200 : 500 // Limite plus petite pour sync incr√©mentale (plus rapide)
        });
        
        syncLogger.info(`   üìä [SALES-SYNC] R√©sultat page ${pageNumber}:`);
        syncLogger.info(`      ‚úÖ Success: ${result.success}`);
        syncLogger.info(`      üì¶ Data length: ${result.data ? result.data.length : 0} ligne(s)`);
        syncLogger.info(`      üìç Next cursor: ${result.next_cursor || 'null (fin de pagination)'}`);
        syncLogger.info(`      ‚úÖ Done: ${result.done !== undefined ? (result.done ? 'true (toutes les pages lues)' : 'false (plus de pages √† lire)') : 'undefined'}`);
        
        // V√©rifier si on a des donn√©es √† appliquer
        if (!result.success) {
          syncLogger.warn(`   ‚ö†Ô∏è  [SALES-SYNC] √âchec du t√©l√©chargement page ${pageNumber}: ${result.error || 'Erreur inconnue'}`);
          break; // Sortir de la boucle en cas d'erreur
        }
        
        if (result.success && result.data && result.data.length > 0) {
          syncLogger.info(`   ‚úÖ [SALES-SYNC] ${result.data.length} ligne(s) t√©l√©charg√©e(s) depuis Sheets en ${Date.now() - salesStartTime}ms`);
          
          // Suivre la date de mise √† jour la plus r√©cente pour mettre √† jour lastPullDate
          for (const item of result.data) {
            const itemUpdatedAt = item._updated_at || item._remote_updated_at || item.sold_at || item.created_at;
            if (itemUpdatedAt) {
              const itemDate = new Date(itemUpdatedAt);
              if (!maxUpdatedAt || itemDate > maxUpdatedAt) {
                maxUpdatedAt = itemDate;
              }
            }
          }
          
          // Log d√©taill√© des premi√®res lignes pour v√©rification
          if (result.data.length > 0) {
            syncLogger.info(`   üìã [SALES-SYNC] Exemple de donn√©es t√©l√©charg√©es (3 premi√®res lignes):`);
            for (let i = 0; i < Math.min(3, result.data.length); i++) {
              const item = result.data[i];
              const updatedAt = item._updated_at || item._remote_updated_at || item.sold_at || 'N/A';
              syncLogger.info(`      [${i + 1}] Facture: ${item.invoice_number || 'N/A'}, Client: ${item.client_name || 'N/A'}, Produit: ${item.product_code || 'N/A'}, Qty: ${item.qty || 0}, Updated: ${updatedAt}`);
            }
          }
          
          // Appliquer les mises √† jour (qui g√®re le groupement par facture)
          syncLogger.info(`   üîÑ [SALES-SYNC] ==========================================`);
          syncLogger.info(`   üîÑ [SALES-SYNC] APPLICATION DES DONN√âES DANS SQLITE`);
          syncLogger.info(`   üîÑ [SALES-SYNC] ==========================================`);
          syncLogger.info(`   üì¶ ${result.data.length} ligne(s) √† traiter ‚Üí Groupement par facture ‚Üí Stockage dans SQLite`);
          syncLogger.info(`   üíæ Tables SQLite: "sales" + "sale_items"`);
          const applyStartTime = Date.now();
          const applyResult = await this.applyUpdates('sales', result.data);
          const applyDuration = Date.now() - applyStartTime;
          
          // V√©rification imm√©diate dans SQLite pour confirmer le stockage
          let salesCountAfter = 0;
          let itemsCountAfter = 0;
          try {
            const { getDb } = await import('../../db/sqlite.js');
            const db = getDb();
            const salesCountResult = db.prepare('SELECT COUNT(*) as count FROM sales WHERE origin = ?').get('SHEETS');
            const itemsCountResult = db.prepare('SELECT COUNT(*) as count FROM sale_items').get();
            salesCountAfter = salesCountResult?.count || 0;
            itemsCountAfter = itemsCountResult?.count || 0;
          } catch (verifyError) {
            syncLogger.error(`   ‚ùå [SALES-SYNC] Erreur v√©rification apr√®s: ${verifyError.message}`);
          }
          
          syncLogger.info(`   ‚úÖ [SALES-SYNC] ==========================================`);
          syncLogger.info(`   ‚úÖ [SALES-SYNC] APPLICATION TERMIN√âE EN ${applyDuration}ms`);
          syncLogger.info(`   ‚úÖ [SALES-SYNC] ==========================================`);
          syncLogger.info(`      üìä R√©sultat de l'application:`);
          syncLogger.info(`         ‚úÖ ${applyResult.inserted || 0} facture(s) CR√â√âE(S) dans SQLite`);
          syncLogger.info(`         ‚úÖ ${applyResult.updated || 0} facture(s) MIS(E) √Ä JOUR dans SQLite`);
          syncLogger.info(`         ‚è≠Ô∏è  ${applyResult.skipped || 0} facture(s) IGNOR√âE(S) (d√©j√† synchronis√©es)`);
          if (applyResult.errorCount && applyResult.errorCount > 0) {
            syncLogger.warn(`         ‚ùå ${applyResult.errorCount} facture(s) EN ERREUR`);
          }
          
          // V√©rification SQLite imm√©diate avec comparaison AVANT/APR√àS
          syncLogger.info(`      üîç [SALES-SYNC] V√âRIFICATION IMM√âDIATE DANS SQLITE:`);
          syncLogger.info(`         üìä AVANT: ${salesCountBefore} vente(s), ${itemsCountBefore} item(s)`);
          syncLogger.info(`         üìä APR√àS: ${salesCountAfter} vente(s), ${itemsCountAfter} item(s)`);
          
          const newSales = salesCountAfter - salesCountBefore;
          const newItems = itemsCountAfter - itemsCountBefore;
          
          if (newSales > 0 || newItems > 0) {
            syncLogger.info(`         ‚úÖ ${newSales} nouvelle(s) vente(s) ajout√©e(s) dans SQLite!`);
            syncLogger.info(`         ‚úÖ ${newItems} nouvel(aux) item(s) ajout√©(s) dans SQLite!`);
          } else if (applyResult.inserted > 0 || applyResult.updated > 0) {
            syncLogger.warn(`         ‚ö†Ô∏è  Des ventes ont √©t√© trait√©es (${applyResult.inserted} cr√©√©e(s), ${applyResult.updated} mise(s) √† jour) mais le nombre total n'a pas chang√©`);
            syncLogger.warn(`         üí° Raison possible: Les ventes existaient d√©j√† et ont √©t√© mises √† jour`);
          } else if (result.data.length > 0) {
            syncLogger.error(`         ‚ùå ERREUR CRITIQUE: ${result.data.length} ligne(s) t√©l√©charg√©e(s) mais aucune vente stock√©e!`);
            syncLogger.error(`         üí° Diagnostic: V√©rifier les logs d'erreur ci-dessus pour chaque facture`);
          }
          
          if (salesCountAfter > 0) {
            syncLogger.info(`      ‚úÖ [SALES-SYNC] CONFIRM√â: ${salesCountAfter} vente(s) stock√©e(s) dans SQLite (table "sales")`);
            syncLogger.info(`      ‚úÖ [SALES-SYNC] CONFIRM√â: ${itemsCountAfter} item(s) stock√©(s) dans SQLite (table "sale_items")`);
            syncLogger.info(`      üíæ Les ventes sont maintenant stock√©es dans la base SQLite locale`);
            syncLogger.info(`      üì± Elles seront visibles dans la page "Historique des ventes"`);
          } else {
            syncLogger.error(`      ‚ùå [SALES-SYNC] ERREUR CRITIQUE: Aucune vente trouv√©e dans SQLite apr√®s l'application!`);
            syncLogger.error(`      üìä [SALES-SYNC] Diagnostic:`);
            syncLogger.error(`         - Lignes t√©l√©charg√©es: ${result.data.length}`);
            syncLogger.error(`         - Factures cr√©√©es: ${applyResult.inserted || 0}`);
            syncLogger.error(`         - Factures mises √† jour: ${applyResult.updated || 0}`);
            syncLogger.error(`         - Factures ignor√©es: ${applyResult.skipped || 0}`);
            syncLogger.error(`      üí° [SALES-SYNC] V√©rifier que applySalesUpdates() fonctionne correctement`);
            syncLogger.error(`      üí° [SALES-SYNC] V√©rifier les logs d'erreur ci-dessus pour chaque facture`);
            
            // Diagnostic suppl√©mentaire
            if (result.data.length > 0) {
              const firstItem = result.data[0];
              syncLogger.error(`      üîç [SALES-SYNC] Exemple de premi√®re ligne t√©l√©charg√©e:`);
              syncLogger.error(`         - invoice_number: ${firstItem.invoice_number || 'MANQUANT'}`);
              syncLogger.error(`         - client_name: ${firstItem.client_name || 'N/A'}`);
              syncLogger.error(`         - product_code: ${firstItem.product_code || 'MANQUANT'}`);
              syncLogger.error(`         - qty: ${firstItem.qty !== undefined ? firstItem.qty : 'MANQUANT'}`);
              syncLogger.error(`         - sold_at: ${firstItem.sold_at || 'MANQUANT'}`);
            }
          }
          
          totalProcessed += result.data.length;
          
          // Mettre √† jour le cursor pour la prochaine it√©ration
          if (result.next_cursor && !result.done) {
            currentCursor = result.next_cursor;
            syncLogger.info(`   üìç [SALES-SYNC] Page ${pageNumber} trait√©e: ${result.data.length} ligne(s) | Total: ${totalProcessed} | Continuation...`);
          } else {
            // Fin de pagination
            isComplete = true;
            syncRepo.setCursor('sales', null);
            syncLogger.info(`   ‚úÖ [SALES-SYNC] Pagination termin√©e: ${totalProcessed} ligne(s) trait√©es au total`);
          }
        } else if (result.success && (!result.data || result.data.length === 0)) {
          // Aucune donn√©e retourn√©e - fin de pagination
          syncLogger.info(`   ‚ÑπÔ∏è  [SALES-SYNC] Page ${pageNumber}: Aucune donn√©e retourn√©e (fin de pagination)`);
          isComplete = true;
          syncRepo.setCursor('sales', null);
        } else {
          // Erreur - sortir de la boucle
          syncLogger.warn(`   ‚ö†Ô∏è  [SALES-SYNC] Erreur page ${pageNumber}: ${result.error || 'Erreur inconnue'}`);
          break;
        }
      }
      
      // Mettre √† jour la date de derni√®re synchronisation apr√®s toutes les pages
      // Utiliser maxUpdatedAt si disponible (plus pr√©cis), sinon utiliser maintenant
      const finalLastPullDate = maxUpdatedAt && maxUpdatedAt > new Date(sinceDate) 
        ? maxUpdatedAt.toISOString() 
        : new Date().toISOString();
      
      syncRepo.setLastPullDate('sales', finalLastPullDate);
      
      if (isIncrementalSync) {
        syncLogger.info(`   ‚úÖ [SALES-SYNC] Sync incr√©mentale termin√©e: ${totalProcessed} ligne(s) trait√©es`);
        syncLogger.info(`   üìÖ [SALES-SYNC] lastPullDate mis √† jour: ${finalLastPullDate} (${new Date(finalLastPullDate).toLocaleString('fr-FR')})`);
      } else {
        syncLogger.info(`üí∞ [SALES-SYNC] SYNCHRONISATION COMPL√àTE TERMIN√âE (${Date.now() - salesStartTime}ms)`);
        syncLogger.info(`üí∞ [SALES-SYNC] Total: ${totalProcessed} ligne(s) trait√©es en ${pageNumber} page(s)`);
      }
      syncLogger.info(`üí∞ [SALES-SYNC] ==========================================`);
      
      // Synchronisation bidirectionnelle : Push des ventes locales vers Sheets
      syncLogger.info(`   üîÑ [SALES-SYNC] D√©marrage synchronisation bidirectionnelle...`);
      try {
        await this.syncLocalSalesToSheets();
      } catch (pushError) {
        syncLogger.warn(`   ‚ö†Ô∏è [SALES-SYNC] Erreur push ventes locales vers Sheets: ${pushError.message}`);
        // Ne pas bloquer si erreur push (peut √™tre hors ligne)
      }
      
      // Nettoyage : Supprimer les ventes locales qui n'existent plus dans Sheets (sauf pending)
      // IMPORTANT: V√©rifier la connexion Internet avant le nettoyage
      // IMPORTANT: Appeler le nettoyage APR√àS chaque synchronisation pour supprimer les ventes supprim√©es dans Sheets
      if (isOnline) {
        try {
          syncLogger.info(`   üßπ [SALES-SYNC] D√©marrage nettoyage des ventes supprim√©es dans Sheets...`);
          await this.cleanupLocalSalesNotInSheets();
          syncLogger.info(`   ‚úÖ [SALES-SYNC] Nettoyage termin√©`);
        } catch (cleanupError) {
          syncLogger.warn(`   ‚ö†Ô∏è [SALES-SYNC] Erreur nettoyage ventes locales: ${cleanupError.message}`);
          // Ne pas bloquer si erreur nettoyage
        }
      } else {
        syncLogger.info(`   ‚è∏Ô∏è [SALES-SYNC] Nettoyage annul√©: pas de connexion Internet`);
      }
      
      // V√©rification automatique post-synchronisation
      syncLogger.info(`   üîç [SALES-SYNC] D√©marrage de la v√©rification automatique...`);
      await this.verifySalesSync();
    } catch (error) {
      syncLogger.error(`   ‚ùå [SALES-SYNC] Erreur: ${error.message}`);
      if (error.stack) {
        syncLogger.error(`      Stack: ${error.stack.substring(0, 300)}...`);
      }
      // Ne pas r√©initialiser le cursor en cas d'erreur pour r√©essayer au prochain cycle
    }
  }
  
  /**
   * V√©rifie que les ventes sont bien synchronis√©es depuis Sheets vers SQLite
   * Compare la structure et le contenu des tables
   */
  async verifySalesSync() {
    try {
      syncLogger.info(`üîç [VERIFY-SALES] ==========================================`);
      syncLogger.info(`üîç [VERIFY-SALES] V√âRIFICATION DE LA SYNCHRONISATION DES VENTES`);
      syncLogger.info(`üîç [VERIFY-SALES] ==========================================`);
      
      const { getDb } = await import('../../db/sqlite.js');
      const db = getDb();
      
      // 1. V√©rifier la structure de la table sales
      syncLogger.info(`   üìã [VERIFY-SALES] V√©rification de la structure SQLite (table: sales)`);
      const salesTableInfo = db.prepare("PRAGMA table_info(sales)").all();
      syncLogger.info(`      ‚úÖ Table 'sales' existe avec ${salesTableInfo.length} colonne(s)`);
      
      const expectedSalesColumns = [
        'id', 'uuid', 'invoice_number', 'sold_at', 'client_name', 'client_phone',
        'seller_name', 'seller_user_id', 'total_fc', 'total_usd', 'rate_fc_per_usd',
        'payment_mode', 'paid_fc', 'paid_usd', 'status', 'origin', 'source_device',
        'created_at', 'updated_at', 'synced_at'
      ];
      
      const actualSalesColumns = salesTableInfo.map(col => col.name);
      const missingSalesColumns = expectedSalesColumns.filter(col => !actualSalesColumns.includes(col));
      if (missingSalesColumns.length > 0) {
        syncLogger.warn(`      ‚ö†Ô∏è  Colonnes manquantes dans 'sales': ${missingSalesColumns.join(', ')}`);
      } else {
        syncLogger.info(`      ‚úÖ Toutes les colonnes attendues sont pr√©sentes dans 'sales'`);
      }
      
      // 2. V√©rifier la structure de la table sale_items
      syncLogger.info(`   üìã [VERIFY-SALES] V√©rification de la structure SQLite (table: sale_items)`);
      const saleItemsTableInfo = db.prepare("PRAGMA table_info(sale_items)").all();
      syncLogger.info(`      ‚úÖ Table 'sale_items' existe avec ${saleItemsTableInfo.length} colonne(s)`);
      
      const expectedSaleItemsColumns = [
        'id', 'uuid', 'sale_id', 'product_id', 'product_code', 'product_name',
        'unit_level', 'unit_mark', 'qty', 'qty_label', 'unit_price_fc',
        'subtotal_fc', 'unit_price_usd', 'subtotal_usd', 'created_at'
      ];
      
      const actualSaleItemsColumns = saleItemsTableInfo.map(col => col.name);
      const missingSaleItemsColumns = expectedSaleItemsColumns.filter(col => !actualSaleItemsColumns.includes(col));
      if (missingSaleItemsColumns.length > 0) {
        syncLogger.warn(`      ‚ö†Ô∏è  Colonnes manquantes dans 'sale_items': ${missingSaleItemsColumns.join(', ')}`);
      } else {
        syncLogger.info(`      ‚úÖ Toutes les colonnes attendues sont pr√©sentes dans 'sale_items'`);
      }
      
      // 3. Compter les ventes dans SQLite
      syncLogger.info(`   üìä [VERIFY-SALES] Comptage des ventes dans SQLite`);
      
      const totalSalesCount = db.prepare('SELECT COUNT(*) as count FROM sales').get();
      const salesFromSheetsCount = db.prepare('SELECT COUNT(*) as count FROM sales WHERE origin = ?').get('SHEETS');
      const salesLocalCount = db.prepare('SELECT COUNT(*) as count FROM sales WHERE origin = ?').get('LOCAL');
      
      syncLogger.info(`      üì¶ Total ventes (sales): ${totalSalesCount.count}`);
      syncLogger.info(`      üì• Ventes depuis Sheets (origin='SHEETS'): ${salesFromSheetsCount.count}`);
      syncLogger.info(`      üíª Ventes locales (origin='LOCAL'): ${salesLocalCount.count}`);
      
      // 4. Compter les items de vente
      const totalSaleItemsCount = db.prepare('SELECT COUNT(*) as count FROM sale_items').get();
      syncLogger.info(`      üì¶ Total items de vente (sale_items): ${totalSaleItemsCount.count}`);
      
      // 5. V√©rifier l'int√©grit√© (ventes sans items)
      const salesWithoutItems = db.prepare(`
        SELECT COUNT(DISTINCT s.id) as count
        FROM sales s
        LEFT JOIN sale_items si ON s.id = si.sale_id
        WHERE si.id IS NULL
      `).get();
      
      if (salesWithoutItems.count > 0) {
        syncLogger.warn(`      ‚ö†Ô∏è  ${salesWithoutItems.count} vente(s) sans items de vente`);
      } else {
        syncLogger.info(`      ‚úÖ Toutes les ventes ont des items associ√©s`);
      }
      
      // 6. Afficher quelques exemples de ventes depuis Sheets
      const sampleSales = db.prepare(`
        SELECT 
          invoice_number, 
          client_name, 
          sold_at, 
          total_fc,
          (SELECT COUNT(*) FROM sale_items WHERE sale_id = sales.id) as items_count
        FROM sales 
        WHERE origin = 'SHEETS' 
        ORDER BY sold_at DESC 
        LIMIT 5
      `).all();
      
      if (sampleSales.length > 0) {
        syncLogger.info(`   üìã [VERIFY-SALES] Exemples de ventes depuis Sheets (5 derni√®res):`);
        for (const sale of sampleSales) {
          syncLogger.info(`      üìÑ Facture: ${sale.invoice_number}, Client: ${sale.client_name || 'N/A'}, Total: ${sale.total_fc} FC, Items: ${sale.items_count}, Date: ${sale.sold_at}`);
        }
      } else {
        syncLogger.warn(`      ‚ö†Ô∏è  Aucune vente depuis Sheets trouv√©e dans SQLite`);
        syncLogger.warn(`      üí° V√©rifier que getSalesPage() dans Code.gs retourne des donn√©es`);
      }
      
      // 7. V√©rifier les colonnes attendues dans Sheets (selon Code.gs)
      syncLogger.info(`   üìã [VERIFY-SALES] Structure attendue dans Google Sheets (feuille "Ventes"):`);
      syncLogger.info(`      Colonnes attendues: Date, Num√©ro de facture, Code produit, client, QTE, MARK, Prix unitaire, Vendeur, mode stock, Telephone, USD, _uuid`);
      syncLogger.info(`      üí° Si getSalesPage() retourne 0 items, v√©rifier que ces colonnes existent dans Sheets`);
      
      syncLogger.info(`üîç [VERIFY-SALES] ==========================================`);
      syncLogger.info(`üîç [VERIFY-SALES] V√âRIFICATION TERMIN√âE`);
      syncLogger.info(`üîç [VERIFY-SALES] ==========================================`);
      
    } catch (error) {
      syncLogger.error(`‚ùå [VERIFY-SALES] Erreur: ${error.message}`);
    }
  }
  
  /**
   * Synchronise les ventes locales vers Google Sheets (push)
   * Ne bloque pas si hors ligne ou erreur
   */
  async syncLocalSalesToSheets() {
    try {
      syncLogger.info(`üîÑ [LOCAL-SALES-PUSH] ==========================================`);
      syncLogger.info(`üîÑ [LOCAL-SALES-PUSH] SYNCHRONISATION VENTES LOCALES ‚Üí SHEETS`);
      syncLogger.info(`üîÑ [LOCAL-SALES-PUSH] ==========================================`);
      
      // V√âRIFIER LA CONNEXION INTERNET AVANT DE COMMENCER
      if (!isOnline) {
        syncLogger.info(`   ‚è∏Ô∏è [LOCAL-SALES-PUSH] Pas de connexion Internet, synchronisation annul√©e`);
        syncLogger.info(`   üí° [LOCAL-SALES-PUSH] La synchronisation sera reprise lorsque la connexion sera r√©tablie`);
        return;
      }
      
      const { getDb } = await import('../../db/sqlite.js');
      const db = getDb();
      
      // R√©cup√©rer TOUTES les ventes locales (y compris celles avec status='pending')
      // IMPORTANT: Pousser toutes les ventes locales vers Sheets pour synchronisation compl√®te
      // Les ventes avec status='pending' seront synchronis√©es et leur statut sera mis √† jour √† 'paid'
      const localSales = db.prepare(`
        SELECT s.*
        FROM sales s
        WHERE s.origin = 'LOCAL'
        ORDER BY s.sold_at DESC
      `).all();
      
      if (!localSales || localSales.length === 0) {
        syncLogger.info(`   ‚úÖ [LOCAL-SALES-PUSH] Aucune vente locale √† synchroniser`);
        return;
      }
      
      // S√©parer les ventes pending des autres
      const pendingSales = localSales.filter(s => s.status === 'pending');
      const otherSales = localSales.filter(s => s.status !== 'pending');
      
      syncLogger.info(`   üì¶ [LOCAL-SALES-PUSH] ${localSales.length} vente(s) locale(s) √† synchroniser vers Sheets`);
      syncLogger.info(`      ‚è≥ ${pendingSales.length} vente(s) avec status='pending' (seront synchronis√©es et pass√©es √† 'paid')`);
      syncLogger.info(`      ‚úÖ ${otherSales.length} vente(s) d√©j√† synchronis√©es (seront mises √† jour)`);
      syncLogger.info(`   üí° [LOCAL-SALES-PUSH] Toutes les ventes locales seront pouss√©es vers Sheets`);
      
      // Pr√©parer les op√©rations pour batchPush (plus efficace)
      const opsToPush = [];
      
      for (const sale of localSales) {
        try {
          // V√©rifier la connexion avant chaque traitement
          if (!isOnline) {
            syncLogger.warn(`   ‚ö†Ô∏è [LOCAL-SALES-PUSH] Connexion Internet perdue, arr√™t de la synchronisation`);
            return;
          }
          
          // R√©cup√©rer les items depuis DB
          const items = db.prepare('SELECT * FROM sale_items WHERE sale_id = ?').all(sale.id);
          
          // Pr√©parer le payload pour Sheets
          // IMPORTANT: Envoyer 'paid' √† Sheets m√™me si localement c'est 'pending'
          // Car une fois synchronis√©e, la vente sera consid√©r√©e comme pay√©e
          const statusForSheets = sale.status === 'pending' ? 'paid' : sale.status;
          
          const payload = {
            uuid: sale.uuid,
            invoice_number: sale.invoice_number,
            sold_at: sale.sold_at,
            client_name: sale.client_name,
            client_phone: sale.client_phone,
            seller_name: sale.seller_name,
            total_fc: sale.total_fc,
            total_usd: sale.total_usd,
            rate_fc_per_usd: sale.rate_fc_per_usd || 2800,
            payment_mode: sale.payment_mode || 'cash',
            paid_fc: sale.paid_fc || 0,
            paid_usd: sale.paid_usd || 0,
            status: statusForSheets, // IMPORTANT: Toujours envoyer 'paid' √† Sheets (m√™me si localement 'pending')
            origin: sale.origin,
            source_device: sale.source_device,
            items: items.map(item => ({
              uuid: item.uuid,
              product_code: item.product_code,
              product_name: item.product_name,
              unit_level: item.unit_level,
              unit_mark: item.unit_mark || '',
              qty: item.qty,
              qty_label: item.qty_label || item.qty.toString(),
              unit_price_fc: item.unit_price_fc,
              subtotal_fc: item.subtotal_fc,
              unit_price_usd: item.unit_price_usd || 0,
              subtotal_usd: item.subtotal_usd || 0
            }))
          };
          
          opsToPush.push({
            entity: 'sales',
            op: 'upsert',
            payload: payload,
            base_remote_updated_at: sale.synced_at || sale.updated_at || sale.sold_at
          });
        } catch (saleError) {
          syncLogger.warn(`   ‚ö†Ô∏è [LOCAL-SALES-PUSH] Erreur pr√©paration vente ${sale.invoice_number}: ${saleError.message}`);
        }
      }
      
      if (opsToPush.length === 0) {
        syncLogger.info(`   ‚úÖ [LOCAL-SALES-PUSH] Aucune op√©ration √† pousser`);
        return;
      }
      
      syncLogger.info(`   üì§ [LOCAL-SALES-PUSH] Envoi de ${opsToPush.length} op√©ration(s) vers Sheets via batchPush...`);
      
      // Utiliser batchPush pour envoyer toutes les ventes en une seule requ√™te (plus efficace)
      const pushResult = await sheetsClient.batchPush(opsToPush);
      
      let pushed = 0;
      let errors = 0;
      
      if (pushResult && pushResult.success) {
        // Mettre √† jour synced_at ET status pour les ventes qui ont √©t√© appliqu√©es avec succ√®s
        // IMPORTANT: Si la vente avait status='pending', la passer √† 'paid' apr√®s synchronisation r√©ussie
        syncLogger.info(`   üìä [LOCAL-SALES-PUSH] ${pushResult.applied?.length || 0} vente(s) appliqu√©e(s) avec succ√®s dans Sheets`);
        
        const syncedInvoiceNumbers = new Set();
        const now = new Date().toISOString();
        
        // Marquer comme synchronis√©es les ventes qui sont dans 'applied'
        for (const appliedOp of pushResult.applied || []) {
          const saleToUpdate = localSales.find(s => s.uuid === appliedOp.uuid || s.invoice_number === appliedOp.invoice_number);
          if (saleToUpdate) {
            const wasPending = saleToUpdate.status === 'pending';
            
            // Mettre √† jour synced_at et status (de 'pending' √† 'paid' si n√©cessaire)
            if (wasPending) {
              db.prepare('UPDATE sales SET synced_at = ?, status = ? WHERE id = ?').run(now, 'paid', saleToUpdate.id);
              syncLogger.info(`   ‚úÖ [LOCAL-SALES-PUSH] Vente ${saleToUpdate.invoice_number} (ID: ${saleToUpdate.id}) synchronis√©e: status 'pending' ‚Üí 'paid', synced_at = ${now}`);
            } else {
              db.prepare('UPDATE sales SET synced_at = ? WHERE id = ?').run(now, saleToUpdate.id);
              syncLogger.info(`   ‚úÖ [LOCAL-SALES-PUSH] Vente ${saleToUpdate.invoice_number} (ID: ${saleToUpdate.id}, Status: ${saleToUpdate.status}) synchronis√©e vers Sheets, synced_at = ${now}`);
            }
            syncedInvoiceNumbers.add(saleToUpdate.invoice_number);
            pushed++;
          } else {
            syncLogger.warn(`   ‚ö†Ô∏è [LOCAL-SALES-PUSH] Vente appliqu√©e dans Sheets mais non trouv√©e localement: ${appliedOp.invoice_number || appliedOp.uuid}`);
          }
        }
        
        // IMPORTANT: Si le push a r√©ussi mais qu'une vente locale n'est pas dans 'applied',
        // cela peut signifier qu'elle existe d√©j√† dans Sheets (mise √† jour plut√¥t qu'insertion)
        // Dans ce cas, on la marque quand m√™me comme synchronis√©e si elle √©tait dans les op√©rations envoy√©es
        const sentInvoiceNumbers = new Set(opsToPush.map(op => op.invoice_number));
        const notInAppliedButSent = localSales.filter(s => 
          sentInvoiceNumbers.has(s.invoice_number) && 
          !syncedInvoiceNumbers.has(s.invoice_number) &&
          !s.synced_at // Ne marquer que si pas d√©j√† synchronis√©e
        );
        
        if (notInAppliedButSent.length > 0) {
          syncLogger.info(`   üí° [LOCAL-SALES-PUSH] ${notInAppliedButSent.length} vente(s) locale(s) envoy√©e(s) mais non dans 'applied' (probablement d√©j√† dans Sheets):`);
          for (const sale of notInAppliedButSent) {
            const wasPending = sale.status === 'pending';
            if (wasPending) {
              db.prepare('UPDATE sales SET synced_at = ?, status = ? WHERE id = ?').run(now, 'paid', sale.id);
              syncLogger.info(`   ‚úÖ [LOCAL-SALES-PUSH] Vente ${sale.invoice_number} (ID: ${sale.id}) marqu√©e comme synchronis√©e: status 'pending' ‚Üí 'paid', synced_at = ${now}`);
            } else {
              db.prepare('UPDATE sales SET synced_at = ? WHERE id = ?').run(now, sale.id);
              syncLogger.info(`   ‚úÖ [LOCAL-SALES-PUSH] Vente ${sale.invoice_number} (ID: ${sale.id}) marqu√©e comme synchronis√©e, synced_at = ${now}`);
            }
            syncedInvoiceNumbers.add(sale.invoice_number);
            if (!syncedInvoiceNumbers.has(sale.invoice_number)) {
              pushed++;
            }
          }
        }
        
        // Log des ventes locales qui n'ont vraiment pas √©t√© synchronis√©es
        const trulyNotSyncedSales = localSales.filter(s => 
          !syncedInvoiceNumbers.has(s.invoice_number) && 
          !sentInvoiceNumbers.has(s.invoice_number)
        );
        if (trulyNotSyncedSales.length > 0) {
          syncLogger.warn(`   ‚ö†Ô∏è [LOCAL-SALES-PUSH] ${trulyNotSyncedSales.length} vente(s) locale(s) n'ont PAS √©t√© envoy√©es ni synchronis√©es:`);
          for (const sale of trulyNotSyncedSales.slice(0, 5)) {
            syncLogger.warn(`      - ${sale.invoice_number} (ID: ${sale.id}, Status: ${sale.status}, Synced: ${sale.synced_at || 'null'})`);
          }
        }
        
        // Compter les conflits comme erreurs
        if (pushResult.conflicts && pushResult.conflicts.length > 0) {
          errors += pushResult.conflicts.length;
          for (const conflict of pushResult.conflicts) {
            syncLogger.warn(`   ‚ö†Ô∏è [LOCAL-SALES-PUSH] Conflit pour vente ${conflict.uuid || conflict.invoice_number}: ${conflict.reason || 'Conflit inconnu'}`);
          }
        }
        
        syncLogger.info(`   ‚úÖ [LOCAL-SALES-PUSH] Synchronisation termin√©e: ${pushed} pouss√©e(s), ${errors} erreur(s)/conflit(s)`);
      } else {
        errors = opsToPush.length;
        syncLogger.warn(`   ‚ö†Ô∏è [LOCAL-SALES-PUSH] √âchec batchPush: ${pushResult?.error || 'Erreur inconnue'}`);
        
        // Marquer comme hors ligne si erreur r√©seau
        if (pushResult?.error && (pushResult.error.includes('timeout') || pushResult.error.includes('ECONNREFUSED') || pushResult.error.includes('ENOTFOUND'))) {
          syncLogger.warn(`   üåê [LOCAL-SALES-PUSH] Connexion Internet perdue d√©tect√©e`);
          isOnline = false;
        }
      }
      
      syncLogger.info(`üîÑ [LOCAL-SALES-PUSH] ==========================================`);
    } catch (error) {
      syncLogger.warn(`   ‚ö†Ô∏è [LOCAL-SALES-PUSH] Erreur globale: ${error.message}`);
      
      // Marquer comme hors ligne si erreur r√©seau
      if (error.code === 'ECONNREFUSED' || error.code === 'ENOTFOUND' || error.code === 'ETIMEDOUT' || error.message?.includes('timeout')) {
        syncLogger.warn(`   üåê [LOCAL-SALES-PUSH] Connexion Internet perdue d√©tect√©e`);
        isOnline = false;
      }
      
      // Ne pas bloquer si erreur (peut √™tre hors ligne)
    }
  }
  
  /**
   * Supprime les ventes locales qui n'existent plus dans Sheets (sauf si status = pending)
   * Ne bloque pas si hors ligne ou erreur
   */
  async cleanupLocalSalesNotInSheets() {
    try {
      syncLogger.info(`üßπ [CLEANUP-SALES] ==========================================`);
      syncLogger.info(`üßπ [CLEANUP-SALES] NETTOYAGE VENTES ABSENTES DE SHEETS`);
      syncLogger.info(`üßπ [CLEANUP-SALES] ==========================================`);
      
      // V√âRIFIER LA CONNEXION INTERNET AVANT DE COMMENCER
      if (!isOnline) {
        syncLogger.info(`   ‚è∏Ô∏è [CLEANUP-SALES] Pas de connexion Internet, nettoyage annul√©`);
        syncLogger.info(`   üí° [CLEANUP-SALES] Le nettoyage sera repris lorsque la connexion sera r√©tablie`);
        return;
      }
      
      const { getDb } = await import('../../db/sqlite.js');
      const db = getDb();
      
      // R√©cup√©rer toutes les factures depuis Sheets (via pull complet)
      syncLogger.info(`   üì• [CLEANUP-SALES] R√©cup√©ration des factures depuis Sheets...`);
      const sheetsInvoices = new Set();
      let cursor = null;
      let done = false;
      let pageCount = 0;
      let totalSheetsRows = 0;
      
      try {
        while (!done && pageCount < 100) { // Limite de s√©curit√©
          pageCount++;
          
          // V√©rifier la connexion avant chaque requ√™te
          if (!isOnline) {
            syncLogger.warn(`   ‚ö†Ô∏è [CLEANUP-SALES] Connexion Internet perdue pendant la r√©cup√©ration, arr√™t du nettoyage`);
            return; // Arr√™ter le nettoyage si connexion perdue
          }
          
          const result = await sheetsClient.pull('sales', new Date(0), {
            full: true,
            cursor: cursor,
            limit: 500
          });
          
          // V√©rifier si la requ√™te a √©chou√© (connexion perdue)
          if (!result.success) {
            syncLogger.warn(`   ‚ö†Ô∏è [CLEANUP-SALES] √âchec de la r√©cup√©ration depuis Sheets: ${result.error || 'Erreur inconnue'}`);
            syncLogger.warn(`   ‚ö†Ô∏è [CLEANUP-SALES] Nettoyage annul√© pour √©viter de supprimer des ventes par erreur`);
            
            // Marquer comme hors ligne si erreur r√©seau
            if (result.error && (result.error.includes('timeout') || result.error.includes('ECONNREFUSED') || result.error.includes('ENOTFOUND'))) {
              syncLogger.warn(`   üåê [CLEANUP-SALES] Connexion Internet perdue d√©tect√©e`);
              isOnline = false;
            }
            
            return; // Arr√™ter le nettoyage si Sheets est inaccessible
          }
          
          if (result.data && result.data.length > 0) {
            result.data.forEach(item => {
              if (item.invoice_number) {
                sheetsInvoices.add(item.invoice_number);
              }
            });
            totalSheetsRows += result.data.length;
            
            if (result.done || !result.next_cursor) {
              done = true;
            } else {
              cursor = result.next_cursor;
            }
          } else {
            done = true;
          }
        }
      } catch (pullError) {
        syncLogger.warn(`   ‚ö†Ô∏è [CLEANUP-SALES] Erreur lors de la r√©cup√©ration depuis Sheets: ${pullError.message}`);
        syncLogger.warn(`   ‚ö†Ô∏è [CLEANUP-SALES] Nettoyage annul√© pour √©viter de supprimer des ventes par erreur`);
        
        // Marquer comme hors ligne si erreur r√©seau
        if (pullError.code === 'ECONNREFUSED' || pullError.code === 'ENOTFOUND' || pullError.code === 'ETIMEDOUT' || pullError.message?.includes('timeout')) {
          syncLogger.warn(`   üåê [CLEANUP-SALES] Connexion Internet perdue d√©tect√©e`);
          isOnline = false;
        }
        
        return; // Arr√™ter le nettoyage si erreur
      }
      
      syncLogger.info(`   üìä [CLEANUP-SALES] ${sheetsInvoices.size} facture(s) unique(s) trouv√©e(s) dans Sheets (${totalSheetsRows} lignes)`);
      
      // IMPORTANT: R√©cup√©rer TOUTES les ventes synchronis√©es (LOCAL et SHEETS) pour comparaison
      // On supprimera celles qui ne sont plus dans Sheets
      // IMPORTANT: Inclure les ventes avec status='pending' MAIS seulement si elles sont synchronis√©es (synced_at != null)
      // Les ventes pending non synchronis√©es seront conserv√©es car elles n'ont pas encore √©t√© envoy√©es √† Sheets
      const allSales = db.prepare(`
        SELECT id, invoice_number, status, sold_at, synced_at, origin
        FROM sales
        ORDER BY sold_at DESC
      `).all();
      
      syncLogger.info(`   üìä [CLEANUP-SALES] ${allSales.length} vente(s) totale(s) dans la base de donn√©es`);
      
      // S√©parer par origine
      const localSales = allSales.filter(s => s.origin === 'LOCAL');
      const sheetsSales = allSales.filter(s => s.origin === 'SHEETS');
      
      syncLogger.info(`   üìä [CLEANUP-SALES] ${localSales.length} vente(s) locale(s), ${sheetsSales.length} vente(s) depuis Sheets`);
      
      // Pour les ventes LOCALES : ne supprimer que celles synchronis√©es (synced_at != null)
      // Les ventes LOCALES non synchronis√©es (m√™me avec status='pending') sont conserv√©es car elles n'ont pas encore √©t√© envoy√©es √† Sheets
      const syncedLocalSales = localSales.filter(s => s.synced_at !== null);
      const notSyncedLocalSales = localSales.filter(s => s.synced_at === null);
      
      // Pour les ventes SHEETS : toutes peuvent √™tre supprim√©es si absentes de Sheets
      // Car si une vente SHEETS n'existe plus dans Sheets, elle a √©t√© supprim√©e et doit √™tre supprim√©e localement aussi
      syncLogger.info(`   üí° [CLEANUP-SALES] Les ventes SHEETS absentes de Sheets seront supprim√©es`);
      syncLogger.info(`   üí° [CLEANUP-SALES] Les ventes LOCALES synchronis√©es (synced_at != null) absentes de Sheets seront supprim√©es`);
      syncLogger.info(`   üí° [CLEANUP-SALES] Les ventes LOCALES non synchronis√©es (synced_at = null) seront conserv√©es (m√™me si status='pending')`);
      syncLogger.info(`   üìä [CLEANUP-SALES] ${syncedLocalSales.length} vente(s) LOCALE(s) synchronis√©e(s) √† v√©rifier`);
      syncLogger.info(`   üìä [CLEANUP-SALES] ${notSyncedLocalSales.length} vente(s) LOCALE(s) non synchronis√©e(s) conserv√©e(s)`);
      
      let deletedLocal = 0;
      let deletedSheets = 0;
      let keptLocal = 0;
      let keptSheets = 0;
      
      // Nettoyer les ventes LOCALES synchronis√©es qui ne sont plus dans Sheets
      // Si une vente LOCALE a √©t√© synchronis√©e (synced_at != null) mais n'existe plus dans Sheets,
      // cela signifie qu'elle a √©t√© supprim√©e dans Sheets et doit √™tre supprim√©e localement aussi
      syncLogger.info(`   üîç [CLEANUP-SALES] V√©rification de ${syncedLocalSales.length} vente(s) LOCALE(s) synchronis√©e(s)...`);
      for (const sale of syncedLocalSales) {
        const isInSheets = sheetsInvoices.has(sale.invoice_number);
        syncLogger.debug(`   üîç [CLEANUP-SALES] Vente LOCALE ${sale.invoice_number} (ID: ${sale.id}, Status: ${sale.status}, Synced: ${sale.synced_at}): ${isInSheets ? '‚úÖ Pr√©sente dans Sheets' : '‚ùå ABSENTE de Sheets ‚Üí SUPPRESSION'}`);
        
        if (!isInSheets) {
          try {
            // IMPORTANT: Supprimer dans l'ordre pour respecter les contraintes de cl√©s √©trang√®res
            // 1. Supprimer les jobs d'impression associ√©s (print_jobs r√©f√©rence invoice_number)
            const printJobsDeleted = db.prepare('DELETE FROM print_jobs WHERE invoice_number = ?').run(sale.invoice_number);
            // 2. Supprimer les paiements de dettes associ√©s (si existent)
            const debtPaymentsDeleted = db.prepare('DELETE FROM debt_payments WHERE debt_id IN (SELECT id FROM debts WHERE sale_id = ?)').run(sale.id);
            // 3. Supprimer les dettes associ√©es (FOREIGN KEY sans CASCADE)
            const debtsDeleted = db.prepare('DELETE FROM debts WHERE sale_id = ?').run(sale.id);
            // 4. Supprimer les annulations de vente (sale_voids) - devrait √™tre CASCADE mais on le fait explicitement
            const voidsDeleted = db.prepare('DELETE FROM sale_voids WHERE sale_id = ?').run(sale.id);
            // 5. Supprimer les items de vente (CASCADE devrait le faire, mais on le fait explicitement)
            const itemsDeleted = db.prepare('DELETE FROM sale_items WHERE sale_id = ?').run(sale.id);
            // 6. Enfin, supprimer la vente elle-m√™me
            db.prepare('DELETE FROM sales WHERE id = ?').run(sale.id);
            deletedLocal++;
            syncLogger.info(`   üóëÔ∏è [CLEANUP-SALES] ‚úÖ Vente LOCALE synchronis√©e ${sale.invoice_number} (ID: ${sale.id}) supprim√©e (absente de Sheets)`);
            syncLogger.info(`      üìã ${itemsDeleted.changes || 0} item(s), ${debtsDeleted.changes || 0} dette(s), ${debtPaymentsDeleted.changes || 0} paiement(s) de dette, ${voidsDeleted.changes || 0} annulation(s), ${printJobsDeleted.changes || 0} job(s) d'impression supprim√©(s)`);
          } catch (deleteError) {
            syncLogger.warn(`   ‚ö†Ô∏è [CLEANUP-SALES] Erreur suppression vente LOCALE ${sale.invoice_number} (ID: ${sale.id}): ${deleteError.message}`);
            syncLogger.warn(`      üìã Stack: ${deleteError.stack?.substring(0, 300)}`);
          }
        } else {
          keptLocal++;
        }
      }
      
      // Nettoyer les ventes SHEETS absentes de Sheets
      // Si une vente SHEETS n'existe plus dans Sheets, elle a √©t√© supprim√©e et doit √™tre supprim√©e localement
      syncLogger.info(`   üîç [CLEANUP-SALES] V√©rification de ${sheetsSales.length} vente(s) SHEETS...`);
      for (const sale of sheetsSales) {
        const isInSheets = sheetsInvoices.has(sale.invoice_number);
        syncLogger.debug(`   üîç [CLEANUP-SALES] Vente SHEETS ${sale.invoice_number} (ID: ${sale.id}): ${isInSheets ? '‚úÖ Pr√©sente dans Sheets' : '‚ùå ABSENTE de Sheets ‚Üí SUPPRESSION'}`);
        
        if (!isInSheets) {
          try {
            // IMPORTANT: Supprimer dans l'ordre pour respecter les contraintes de cl√©s √©trang√®res
            // 1. Supprimer les jobs d'impression associ√©s (print_jobs r√©f√©rence invoice_number)
            const printJobsDeleted = db.prepare('DELETE FROM print_jobs WHERE invoice_number = ?').run(sale.invoice_number);
            // 2. Supprimer les paiements de dettes associ√©s (si existent)
            const debtPaymentsDeleted = db.prepare('DELETE FROM debt_payments WHERE debt_id IN (SELECT id FROM debts WHERE sale_id = ?)').run(sale.id);
            // 3. Supprimer les dettes associ√©es (FOREIGN KEY sans CASCADE)
            const debtsDeleted = db.prepare('DELETE FROM debts WHERE sale_id = ?').run(sale.id);
            // 4. Supprimer les annulations de vente (sale_voids) - devrait √™tre CASCADE mais on le fait explicitement
            const voidsDeleted = db.prepare('DELETE FROM sale_voids WHERE sale_id = ?').run(sale.id);
            // 5. Supprimer les items de vente (CASCADE devrait le faire, mais on le fait explicitement)
            const itemsDeleted = db.prepare('DELETE FROM sale_items WHERE sale_id = ?').run(sale.id);
            // 6. Enfin, supprimer la vente elle-m√™me
            db.prepare('DELETE FROM sales WHERE id = ?').run(sale.id);
            deletedSheets++;
            syncLogger.info(`   üóëÔ∏è [CLEANUP-SALES] ‚úÖ Vente SHEETS ${sale.invoice_number} (ID: ${sale.id}) supprim√©e (absente de Sheets)`);
            syncLogger.info(`      üìã ${itemsDeleted.changes || 0} item(s), ${debtsDeleted.changes || 0} dette(s), ${debtPaymentsDeleted.changes || 0} paiement(s) de dette, ${voidsDeleted.changes || 0} annulation(s), ${printJobsDeleted.changes || 0} job(s) d'impression supprim√©(s)`);
          } catch (deleteError) {
            syncLogger.warn(`   ‚ö†Ô∏è [CLEANUP-SALES] Erreur suppression vente SHEETS ${sale.invoice_number} (ID: ${sale.id}): ${deleteError.message}`);
            syncLogger.warn(`      üìã Stack: ${deleteError.stack?.substring(0, 300)}`);
          }
        } else {
          keptSheets++;
        }
      }
      
      syncLogger.info(`   ‚úÖ [CLEANUP-SALES] Nettoyage termin√©:`);
      syncLogger.info(`      üóëÔ∏è ${deletedLocal} vente(s) LOCALE(s) synchronis√©e(s) supprim√©e(s) (absentes de Sheets)`);
      syncLogger.info(`      üóëÔ∏è ${deletedSheets} vente(s) SHEETS supprim√©e(s) (absentes de Sheets)`);
      syncLogger.info(`      ‚úÖ ${keptLocal} vente(s) LOCALE(s) synchronis√©e(s) conserv√©e(s) (pr√©sentes dans Sheets)`);
      syncLogger.info(`      ‚úÖ ${keptSheets} vente(s) SHEETS conserv√©e(s) (pr√©sentes dans Sheets)`);
      syncLogger.info(`      ‚è≠Ô∏è ${notSyncedLocalSales.length} vente(s) LOCALE(s) non synchronis√©e(s) conserv√©e(s) (seront synchronis√©es plus tard)`);
      
      // V√©rification finale : compter les ventes restantes
      const remainingSales = db.prepare('SELECT COUNT(*) as count FROM sales WHERE status != ?').get('pending');
      syncLogger.info(`      üìä Total ventes restantes (hors pending): ${remainingSales.count}`);
      
      if (deletedLocal > 0 || deletedSheets > 0) {
        syncLogger.info(`   üéâ [CLEANUP-SALES] ‚úÖ Nettoyage r√©ussi: ${deletedLocal + deletedSheets} vente(s) supprim√©e(s) qui n'existent plus dans Sheets`);
        syncLogger.info(`   üí° [CLEANUP-SALES] Ces ventes ne seront plus affich√©es dans la page "Historique des ventes"`);
      }
      
      syncLogger.info(`üßπ [CLEANUP-SALES] ==========================================`);
    } catch (error) {
      syncLogger.warn(`   ‚ö†Ô∏è [CLEANUP-SALES] Erreur globale: ${error.message}`);
      
      // Marquer comme hors ligne si erreur r√©seau
      if (error.code === 'ECONNREFUSED' || error.code === 'ENOTFOUND' || error.code === 'ETIMEDOUT' || error.message?.includes('timeout')) {
        syncLogger.warn(`   üåê [CLEANUP-SALES] Connexion Internet perdue d√©tect√©e`);
        isOnline = false;
      }
      
      // Ne pas bloquer si erreur (peut √™tre hors ligne)
    }
  }

  /**
   * Configure la d√©tection automatique de connexion Internet (en temps r√©el)
   * Optimis√© pour ne pas bloquer l'event loop
   */
  setupConnectionDetection() {
    // V√©rifier la connexion toutes les 15 secondes (r√©duit la charge)
    setInterval(() => {
      // Utiliser setImmediate pour ne pas bloquer l'event loop
      setImmediate(() => {
        this.checkConnection().catch(() => {
          // Ignorer les erreurs silencieusement pour ne pas polluer les logs
        });
      });
    }, 15000); // V√©rifier toutes les 15 secondes (au lieu de 5s)
  }

  /**
   * V√©rifie si une connexion Internet est disponible (d√©tection automatique en arri√®re-plan)
   */
  async checkConnection() {
    const webAppUrl = process.env.GOOGLE_SHEETS_WEBAPP_URL;
    if (!webAppUrl) {
      return; // Pas d'URL configur√©e
    }

    try {
      const axios = (await import('axios')).default;
      
      // Essayer de pinger Google Sheets avec un timeout court
      const response = await axios.get(webAppUrl, {
        params: { entity: 'test' },
        timeout: 3000, // 3 secondes de timeout
        validateStatus: (status) => status < 500, // Accepter m√™me les erreurs 4xx (signe de connexion)
      });
      
      // Si on arrive ici, la connexion est disponible
      if (!isOnline) {
        syncLogger.info('üåê [INTERNET] Connexion Internet d√©tect√©e automatiquement, reprise de la synchronisation');
        isOnline = true;
        
        // Si l'import initial n'a pas √©t√© fait, charger imm√©diatement tous les produits
        const initialImportDone = syncRepo.isInitialImportDone();
        const isDatabaseEmpty = !productsRepo.hasProducts();
        if (!initialImportDone && isDatabaseEmpty) {
          syncLogger.info('üì• [AUTO-SYNC] Base de donn√©es vide, import initial automatique depuis Google Sheets...');
          // Import initial complet en arri√®re-plan (non-bloquant)
          this.pullUpdates(true).catch(err => {
            syncLogger.error('‚ùå [AUTO-SYNC] Erreur lors de l\'import initial automatique:', err);
          });
        } else {
          // Relancer une sync imm√©diate (non-bloquant)
          syncLogger.info('üîÑ [AUTO-SYNC] Synchronisation automatique d√©clench√©e apr√®s d√©tection Internet');
          this.runSyncSafe().catch(err => {
            syncLogger.error('‚ùå [AUTO-SYNC] Erreur lors de la sync automatique:', err);
          });
        }
      }
    } catch (error) {
      // Pas de connexion ou timeout
      if (isOnline && (error.code === 'ECONNREFUSED' || error.code === 'ENOTFOUND' || error.code === 'ETIMEDOUT' || error.message?.includes('timeout'))) {
        syncLogger.warn('‚ö†Ô∏è [INTERNET] Connexion Internet perdue, synchronisation en attente');
        isOnline = false;
      }
    }
  }

  /**
   * Arr√™te le worker
   */
  stop() {
    _started = false;
    if (syncInterval) {
      clearInterval(syncInterval);
      syncInterval = null;
    }
    if (_loopTimeout) {
      clearTimeout(_loopTimeout);
      _loopTimeout = null;
    }
    if (_salesLoopTimeout) {
      clearTimeout(_salesLoopTimeout);
      _salesLoopTimeout = null;
    }
    syncLogger.info('Worker de synchronisation arr√™t√©');
    syncLogger.info('üí∞ [SALES-SYNC] Synchronisation d√©di√©e des ventes arr√™t√©e');
  }

  /**
   * Wrapper s√©curis√© pour sync() avec mutex anti-overlap et timeout
   * Optimis√© pour ne pas bloquer l'event loop
   */
  async runSyncSafe() {
    if (syncRunning) {
      syncLogger.warn('‚è≠Ô∏è Sync d√©j√† en cours, skip');
      return;
    }
    syncRunning = true;
    
    // Timeout de s√©curit√© (3 minutes max, r√©duit de 5min)
    const timeout = setTimeout(() => {
      if (syncRunning) {
        syncLogger.error('‚è±Ô∏è Timeout: Sync prend trop de temps (>3min), arr√™t forc√©');
        syncRunning = false;
        isSyncing = false;
      }
    }, 3 * 60 * 1000);
    
    try {
      // Utiliser setImmediate pour diff√©rer la sync et donner priorit√© aux requ√™tes API
      await new Promise((resolve, reject) => {
        setImmediate(async () => {
          try {
            await this.sync();
            resolve();
          } catch (error) {
            reject(error);
          }
        });
      });
    } catch (error) {
      syncLogger.error('‚ùå Sync error', error);
      // Ne pas planter l'application, juste logger l'erreur
      if (error.message?.includes('ECONNREFUSED') || error.message?.includes('ETIMEDOUT')) {
        syncLogger.warn('‚ö†Ô∏è Probl√®me de connexion, sync sera r√©essay√©e au prochain cycle');
      }
    } finally {
      clearTimeout(timeout);
      // Utiliser setImmediate pour lib√©rer le mutex de mani√®re non-bloquante
      setImmediate(() => {
        syncRunning = false;
      });
    }
  }

  /**
   * Effectue une synchronisation compl√®te avec gestion d'erreurs robuste
   * Optimis√© pour ne pas bloquer l'event loop
   */
  async sync() {
    if (isSyncing) {
      return; // D√©j√† en cours
    }

    isSyncing = true;
    const syncStartTime = Date.now();

    try {
      // Utiliser setImmediate pour diff√©rer chaque √©tape et donner priorit√© aux requ√™tes API
      // Push: envoyer les op√©rations en attente (avec timeout)
      try {
        await new Promise((resolve, reject) => {
          setImmediate(async () => {
            try {
              await Promise.race([
                this.pushPending(),
                new Promise((_, rejectTimeout) => 
                  setTimeout(() => rejectTimeout(new Error('Push timeout')), 2 * 60 * 1000)
                )
              ]);
              resolve();
            } catch (error) {
              reject(error);
            }
          });
        });
      } catch (pushError) {
        syncLogger.warn('‚ö†Ô∏è Erreur push (non bloquant):', pushError.message);
        // Continue m√™me si push √©choue
      }

      // Pull: r√©cup√©rer les donn√©es depuis Sheets (avec timeout)
      // Utiliser process.nextTick pour donner encore plus de priorit√© aux requ√™tes API
      try {
        await new Promise((resolve, reject) => {
          process.nextTick(async () => {
            try {
              await Promise.race([
                this.pullUpdates(),
                new Promise((_, rejectTimeout) => 
                  setTimeout(() => rejectTimeout(new Error('Pull timeout')), 3 * 60 * 1000)
                )
              ]);
              resolve();
            } catch (error) {
              reject(error);
            }
          });
        });
      } catch (pullError) {
        syncLogger.warn('‚ö†Ô∏è Erreur pull (non bloquant):', pullError.message);
        // Continue m√™me si pull √©choue partiellement
      }
      
      const duration = Date.now() - syncStartTime;
      syncLogger.debug(`‚úÖ Sync termin√©e en ${duration}ms`);
    } catch (error) {
      syncLogger.error('‚ùå Erreur lors de la synchronisation:', error);
      // Ne pas propager l'erreur pour √©viter de planter l'application
    } finally {
      // Lib√©rer le flag de mani√®re non-bloquante
      setImmediate(() => {
        isSyncing = false;
      });
    }
  }

  /**
   * Push les op√©rations en attente vers Google Sheets (mode PRO avec batch ou concurrence limit√©e)
   */
  async pushPending() {
    // Ne pas push si pas de connexion
    if (!isOnline) {
      syncLogger.debug(`‚è∏Ô∏è  [PUSH] Pas de connexion Internet, push annul√©`);
      return;
    }

    try {
      const pending = syncRepo.getPending(200); // Max 200 par batch

      if (pending.length === 0) {
        syncLogger.debug(`üì≠ [PUSH] Aucune op√©ration en attente`);
        return;
      }

      syncLogger.info(`üì§ [PUSH] ==========================================`);
      syncLogger.info(`üì§ [PUSH] PUSH DE ${pending.length} OP√âRATION(S) VERS SHEETS`);
      syncLogger.info(`üì§ [PUSH] ==========================================`);
      
      // LOG: D√©tails des op√©rations update_stock
      const stockUpdates = pending.filter(op => op.op === 'update_stock');
      if (stockUpdates.length > 0) {
        syncLogger.info(`üì¶ [PUSH] ${stockUpdates.length} op√©ration(s) update_stock trouv√©e(s):`);
        stockUpdates.forEach((op, idx) => {
          const payload = JSON.parse(op.payload_json || JSON.stringify(op.payload || {}));
          syncLogger.info(`   [${idx + 1}] Produit: ${payload.product_code}`);
          syncLogger.info(`       Unit√©: ${payload.unit_level}, Mark: ${payload.unit_mark || '(vide)'}`);
          if (payload.stock_absolute !== undefined) {
            syncLogger.info(`       Stock ABSOLU: ${payload.stock_absolute} (√©crasera colonne C dans Sheets)`);
          }
          if (payload.stock_change !== undefined) {
            syncLogger.info(`       Stock change (relatif): ${payload.stock_change}`);
          }
          syncLogger.info(`       Invoice: ${payload.invoice_number || '(vide)'}`);
        });
      }

      // Pr√©parer les ops pour batch
      const ops = pending.map(op => ({
        op_id: op.id,
        entity: op.entity,
        entity_id: op.entity_id,
        op: op.op,
        payload: JSON.parse(op.payload_json || JSON.stringify(op.payload || {}))
      }));

      syncLogger.info(`üì§ [PUSH] Envoi du batch vers Google Sheets...`);
      
      // Essayer batch d'abord, sinon fallback en concurrence limit√©e
      const batchResult = await sheetsClient.pushBatch(ops, { timeout: 9000 });

      // Traiter les r√©sultats
      syncLogger.info(`üì§ [PUSH] R√©sultat du batch:`);
      syncLogger.info(`   Success: ${batchResult.success}`);
      syncLogger.info(`   Applied: ${batchResult.applied?.length || 0} op√©ration(s)`);
      syncLogger.info(`   Conflicts: ${batchResult.conflicts?.length || 0} conflit(s)`);
      if (batchResult.error) {
        syncLogger.error(`   Erreur: ${batchResult.error}`);
      }
      
      if (batchResult.applied) {
        const appliedStockUpdates = batchResult.applied.filter(applied => {
          const op = ops.find(o => o.op_id === applied.op_id);
          return op && op.op === 'update_stock';
        });
        
        if (appliedStockUpdates.length > 0) {
          syncLogger.info(`‚úÖ [PUSH] ${appliedStockUpdates.length} op√©ration(s) update_stock appliqu√©e(s) avec succ√®s dans Sheets`);
        }
        
        for (const applied of batchResult.applied) {
          syncRepo.markAsSent(applied.op_id);
        }
        syncLogger.info(`   ‚úÖ [PUSH] ${batchResult.applied.length} op√©ration(s) appliqu√©e(s)`);
      }

      if (batchResult.conflicts && batchResult.conflicts.length > 0) {
        for (const conflict of batchResult.conflicts) {
          syncRepo.markAsError(conflict.op_id, new Error(conflict.error || 'Conflit'));
        }
        syncLogger.warn(`   ‚ö†Ô∏è  [PUSH] ${batchResult.conflicts.length} conflit(s)`);
      }

            // Si erreur r√©seau, marquer comme hors ligne
      if (!batchResult.success && batchResult.error) {
        if (batchResult.error.includes('network') || batchResult.error.includes('ECONNREFUSED') || batchResult.error.includes('timeout')) {
              isOnline = false;
            }
          }
        } catch (error) {
      syncLogger.error('‚ùå [PUSH] Erreur pushPending:', error.message);
          // Si erreur r√©seau, marquer comme hors ligne
          if (error.code === 'ECONNREFUSED' || error.code === 'ENOTFOUND' || error.code === 'ETIMEDOUT') {
            isOnline = false;
          }
    }
  }

  /**
   * Pull les mises √† jour depuis Google Sheets - Mode PRO avec pagination
   * T√©l√©charge TOUTES les feuilles (Carton, Piece, Milliers, Ventes, Dettes, etc.)
   * @param {boolean} isInitialImport - Si true, import complet pagin√© (ignore les dates)
   */
  async pullUpdates(isInitialImport = false) {
    // V√©rifier la connexion Internet
    if (!isOnline && !isInitialImport) {
      syncLogger.debug('Hors ligne, pull ignor√©');
      return;
    }

    // BOOTSTRAP AUTOMATIQUE : Si table vide ‚Üí forcer full pull
    const isProductsEmpty = !productsRepo.hasProducts();
    if (isProductsEmpty && !isInitialImport) {
      syncLogger.warn('‚ö†Ô∏è  [BOOTSTRAP AUTO] Table products vide d√©tect√©e ‚Üí Passage en mode FULL PULL');
      isInitialImport = true; // Forcer le mode full pull
    }

    // V√©rifier si les utilisateurs sont vides
    const usersCount = usersRepo.findAll().length;
    const isUsersEmpty = usersCount === 0;
    if (isUsersEmpty) {
      syncLogger.warn(`‚ö†Ô∏è  [BOOTSTRAP AUTO] Table users vide d√©tect√©e (${usersCount} utilisateur(s)) ‚Üí Forcer import complet pour users`);
    } else {
      // M√™me si la base n'est pas vide, forcer un import complet pour r√©cup√©rer TOUS les utilisateurs
      // Cela garantit que tous les utilisateurs (anciens et nouveaux) sont synchronis√©s
      syncLogger.info(`üë• [USERS] Base contient ${usersCount} utilisateur(s) ‚Üí Import complet pour r√©cup√©rer TOUS les utilisateurs (anciens et nouveaux)`);
    }

    const globalStartTime = Date.now();
    syncLogger.info(`üîÑ D√©but pull depuis Google Sheets${isInitialImport ? ' (BOOTSTRAP/FULL - TOUT EN UNE FOIS)' : ' (synchronisation incr√©mentale)'}`);
    syncLogger.info(`   ‚è∞ D√©but: ${new Date().toISOString()}`);
    syncLogger.info(`   üìã T√©l√©chargement de TOUTES les feuilles: Products (Carton/Piece/Milliers), Sales, Debts, Rates, Users`);

    try {
      const entities = ['users', 'rates', 'debts', 'products', 'sales'];
      const results = [];
      
      // Construire sinceMap pour tous
      const sinceMap = {};
      syncLogger.info(`   üìÖ [SYNC] Dates 'since' utilis√©es pour chaque entit√©:`);
      for (const e of entities) {
        const lastPullDate = syncRepo.getLastPullDate(e);
        
        // V√©rifier si la base est vide pour cette entit√©
        // Pour les utilisateurs, TOUJOURS forcer un import complet pour r√©cup√©rer TOUS les utilisateurs
        let forceFullImport = isInitialImport;
        if (e === 'users') {
          forceFullImport = true; // TOUJOURS r√©cup√©rer tous les utilisateurs
          syncLogger.info(`   üë• [USERS] Import complet forc√© ‚Üí R√©cup√©ration de TOUS les utilisateurs (date since = 1970)`);
        }
        
        // Si bootstrap/full import ou base vide ‚Üí date tr√®s ancienne (1970)
        sinceMap[e] = forceFullImport ? new Date(0).toISOString() : (lastPullDate || new Date(0).toISOString());
        const sinceDate = new Date(sinceMap[e]);
        syncLogger.info(`      - ${e.toUpperCase()}: ${sinceMap[e]} (${sinceDate.toLocaleString('fr-FR')})${forceFullImport ? ' üöÄ BOOTSTRAP/FULL' : (!lastPullDate ? ' ‚ö†Ô∏è AUCUNE DATE PR√âC√âDENTE - Import complet' : '')}`);
      }
      
      // Mode PRO: Full import pagin√© si initial, sinon incr√©mental
      if (isInitialImport) {
        syncLogger.info(`   üöÄ [FULL IMPORT] Mode pagin√© activ√© pour import complet`);
        
        // 1) L√©gers (users, rates, debts) - pas de pagination n√©cessaire
        const lightEntities = ['users', 'rates', 'debts'];
        syncLogger.info(`   ‚ö° [FULL IMPORT] Pull des entit√©s l√©g√®res: ${lightEntities.join(', ')}`);
        
        for (const entity of lightEntities) {
          const entityStartTime = Date.now();
          try {
            if (entity === 'users') {
              syncLogger.info(`   üë• [USERS] D√©but pull depuis Google Sheets...`);
              syncLogger.info(`   üë• [USERS] Since date: ${sinceMap[entity]}`);
            }
            
            const result = await sheetsClient.pullAllPaged(entity, sinceMap[entity], {
              full: true,
              maxRetries: 8,
              timeout: 30000
            });
            
            if (entity === 'users') {
              syncLogger.info(`   üë• [USERS] R√©sultat pull: success=${result.success}, data.length=${result.data?.length || 0}`);
              if (result.error) {
                syncLogger.error(`   üë• [USERS] Erreur pull: ${result.error}`);
              }
              if (result.data && result.data.length > 0) {
                syncLogger.info(`   üë• [USERS] Premier utilisateur re√ßu:`, JSON.stringify(result.data[0]).substring(0, 200));
              }
            }
            
            if (result.success && result.data.length > 0) {
              syncLogger.info(`   ‚úÖ [${entity.toUpperCase()}] ${result.data.length} item(s) t√©l√©charg√©(s) en ${Date.now() - entityStartTime}ms`);
              await this.applyUpdates(entity, result.data);
              syncRepo.setLastPullDate(entity, new Date().toISOString());
              results.push({ entity, success: true, data: result.data, duration: Date.now() - entityStartTime });
            } else {
              syncLogger.warn(`   ‚è≠Ô∏è  [${entity.toUpperCase()}] Aucune donn√©e ou erreur`);
              if (entity === 'users' && result.error) {
                syncLogger.error(`   üë• [USERS] D√©tails erreur:`, result.error);
              }
              results.push({ entity, success: result.success, data: result.data || [], error: result.error, skipped: !result.success });
            }
          } catch (error) {
            syncLogger.error(`   ‚ùå [${entity.toUpperCase()}] Erreur: ${error.message}`);
            if (entity === 'users') {
              syncLogger.error(`   üë• [USERS] Stack trace:`, error.stack);
            }
            results.push({ entity, success: false, data: [], error: error.message, skipped: true });
          }
        }
        
        // 2) Products - pagin√© par unit_level (Carton, Milliers, Piece)
        syncLogger.info(`   üì¶ [FULL IMPORT] Pull pagin√© Products (Carton, Milliers, Piece)...`);
        const productUnitLevels = ['CARTON', 'MILLIER', 'PIECE'];
        const allProducts = [];
        
        for (const unitLevel of productUnitLevels) {
          const unitStartTime = Date.now();
          syncLogger.info(`   üìÑ [PRODUCTS] Feuille: ${unitLevel}`);
          
          try {
            const cursor = syncRepo.getCursor('products', unitLevel);
            const result = await sheetsClient.pullAllPaged('products', sinceMap['products'], {
              full: true,
              unitLevel: unitLevel,
              startCursor: cursor,
              maxRetries: 8,
              timeout: 30000,
              limit: 300
            });
            
            if (result.success) {
              allProducts.push(...result.data);
              syncLogger.info(`   ‚úÖ [PRODUCTS/${unitLevel}] ${result.data.length} produit(s) en ${Date.now() - unitStartTime}ms`);
              syncRepo.setCursor('products', result.last_cursor || null, unitLevel);
            } else {
              syncLogger.warn(`   ‚ö†Ô∏è [PRODUCTS/${unitLevel}] Erreur: ${result.error}`);
            }
          } catch (error) {
            syncLogger.error(`   ‚ùå [PRODUCTS/${unitLevel}] Erreur: ${error.message}`);
          }
        }
        
        // Grouper products par code et appliquer
        if (allProducts.length > 0) {
          syncLogger.info(`   üì¶ [PRODUCTS] Total: ${allProducts.length} produit(s) √† appliquer`);
          try {
            await this.applyUpdates('products', allProducts);
            syncRepo.setLastPullDate('products', new Date().toISOString());
            if (!syncRepo.isInitialImportDone()) {
              syncRepo.setInitialImportDone();
              syncLogger.info(`   üéâ [IMPORT] Import initial termin√© avec succ√®s (${allProducts.length} produit(s))`);
            }
            results.push({ entity: 'products', success: true, data: allProducts, duration: 0 });
          } catch (applyError) {
            syncLogger.error(`   ‚ùå [PRODUCTS] Erreur application: ${applyError.message}`);
            results.push({ entity: 'products', success: false, data: [], error: applyError.message, skipped: true });
          }
        }
        
        // 3) Sales - pagin√©
        syncLogger.info(`   üí∞ [FULL IMPORT] Pull pagin√© Sales...`);
        const salesStartTime = Date.now();
        try {
          const cursor = syncRepo.getCursor('sales');
          const cursorStr = cursor ? String(cursor) : null;
          syncLogger.info(`   üìç [SALES] Cursor: ${cursorStr ? (cursorStr.length > 50 ? cursorStr.substring(0, 50) + '...' : cursorStr) : 'null (d√©but)'}`);
          
          const result = await sheetsClient.pullAllPaged('sales', sinceMap['sales'], {
            full: true,
            startCursor: cursor,
            maxRetries: 8,
            timeout: 30000,
            limit: 300
          });
          
          syncLogger.info(`   üìä [SALES] R√©sultat pullAllPaged:`);
          syncLogger.info(`      ‚úÖ Success: ${result.success}`);
          syncLogger.info(`      üì¶ Data length: ${result.data ? result.data.length : 0} ligne(s)`);
          syncLogger.info(`      üìç Next cursor: ${result.last_cursor || 'null (fin)'}`);
          syncLogger.info(`      ‚úÖ Done: ${result.done ? 'true' : 'false'}`);
          
          if (result.success && result.data && result.data.length > 0) {
            syncLogger.info(`   ‚úÖ [SALES] ${result.data.length} ligne(s) t√©l√©charg√©e(s) en ${Date.now() - salesStartTime}ms`);
            syncLogger.info(`   üîÑ [SALES] Application dans SQLite...`);
            
            // V√©rification avant application
            let salesCountBefore = 0;
            try {
              const { getDb } = await import('../../db/sqlite.js');
              const db = getDb();
              const countResult = db.prepare('SELECT COUNT(*) as count FROM sales WHERE origin = ?').get('SHEETS');
              salesCountBefore = countResult?.count || 0;
              syncLogger.info(`   üîç [SALES] Ventes avant application: ${salesCountBefore}`);
            } catch (countError) {
              syncLogger.warn(`   ‚ö†Ô∏è  [SALES] Erreur comptage avant: ${countError.message}`);
            }
            
            try {
              const applyResult = await this.applyUpdates('sales', result.data);
              syncLogger.info(`   ‚úÖ [SALES] Application termin√©e: ${applyResult.inserted || 0} cr√©√©e(s), ${applyResult.updated || 0} mise(s) √† jour`);
              
              // V√©rification apr√®s application
              let salesCountAfter = 0;
              try {
                const { getDb } = await import('../../db/sqlite.js');
                const db = getDb();
                const countResult = db.prepare('SELECT COUNT(*) as count FROM sales WHERE origin = ?').get('SHEETS');
                salesCountAfter = countResult?.count || 0;
                syncLogger.info(`   üîç [SALES] Ventes apr√®s application: ${salesCountAfter}`);
                
                const newSales = salesCountAfter - salesCountBefore;
                if (newSales > 0) {
                  syncLogger.info(`   ‚úÖ [SALES] ${newSales} nouvelle(s) vente(s) ajout√©e(s) avec succ√®s!`);
                } else if (applyResult.inserted > 0 || applyResult.updated > 0) {
                  syncLogger.warn(`   ‚ö†Ô∏è  [SALES] Des ventes ont √©t√© trait√©es mais le nombre total n'a pas chang√©`);
                }
              } catch (countError) {
                syncLogger.warn(`   ‚ö†Ô∏è  [SALES] Erreur comptage apr√®s: ${countError.message}`);
              }
              
              syncRepo.setLastPullDate('sales', new Date().toISOString());
              syncRepo.setCursor('sales', result.last_cursor || null);
              results.push({ entity: 'sales', success: true, data: result.data, duration: Date.now() - salesStartTime });
            } catch (applyError) {
              syncLogger.error(`   ‚ùå [SALES] ERREUR lors de l'application: ${applyError.message}`);
              syncLogger.error(`   üìã [SALES] Stack: ${applyError.stack?.substring(0, 500)}`);
              results.push({ entity: 'sales', success: false, data: [], error: applyError.message, skipped: true });
            }
          } else if (result.success) {
            syncLogger.warn(`   ‚è≠Ô∏è [SALES] Aucune donn√©e retourn√©e (0 ligne)`);
            syncLogger.warn(`   üí° [SALES] Raisons possibles:`);
            syncLogger.warn(`      - Feuille "Ventes" vide dans Google Sheets`);
            syncLogger.warn(`      - Toutes les ventes filtr√©es par date`);
            syncLogger.warn(`      - Cursor invalide`);
            results.push({ entity: 'sales', success: true, data: [], error: 'Aucune donn√©e', skipped: false });
          } else {
            syncLogger.error(`   ‚ùå [SALES] Erreur lors du pull: ${result.error || 'Erreur inconnue'}`);
            results.push({ entity: 'sales', success: false, data: [], error: result.error, skipped: true });
          }
        } catch (error) {
          syncLogger.error(`   ‚ùå [SALES] Erreur: ${error.message}`);
          syncLogger.error(`   üìã [SALES] Stack: ${error.stack?.substring(0, 500)}`);
          results.push({ entity: 'sales', success: false, data: [], error: error.message, skipped: true });
        }
        
      } else {
        // Mode incr√©mental normal (rapide)
        syncLogger.info(`   üîÑ [SYNC INCR√âMENTALE] Mode rapide (depuis lastPullDate)`);
        
        // Pour les utilisateurs, TOUJOURS forcer un import complet m√™me en mode incr√©mental
        // Cela garantit que tous les utilisateurs (anciens et nouveaux) sont r√©cup√©r√©s
        syncLogger.info(`   üë• [USERS] Import complet forc√© m√™me en mode incr√©mental ‚Üí R√©cup√©ration de TOUS les utilisateurs`);
        sinceMap['users'] = new Date(0).toISOString();
        
        // Pull en parall√®le limit√© (l√©gers d'abord)
        const lightEntities = ['users', 'rates', 'debts'];
        // Sales exclu: synchronis√© s√©par√©ment toutes les 10s avec pagination via startSalesSyncLoop()
        const heavyEntities = ['products'];
        
        syncLogger.info(`   ‚ö° [SYNC] Pull parall√®le des entit√©s l√©g√®res: ${lightEntities.join(', ')}`);
        if (isUsersEmpty) {
          syncLogger.info(`   üë• [USERS] Date 'since' forc√©e √† 1970 pour import complet: ${sinceMap['users']}`);
        }
        const lightResults = await sheetsClient.pullMany(lightEntities, sinceMap, { 
          maxRetries: 1 
        });
        
        // Appliquer imm√©diatement les r√©sultats l√©gers
        for (const r of lightResults) {
          if (r.success && r.data && r.data.length > 0) {
            syncLogger.info(`   ‚úÖ [${r.entity.toUpperCase()}] ${r.data.length} item(s) t√©l√©charg√©(s)`);
            try {
              await this.applyUpdates(r.entity, r.data);
              // Utiliser max_updated_at si disponible
              const maxUpdated = r.data.reduce((max, item) => {
                const itemDate = item._remote_updated_at || item.last_update || item.created_at || item.sold_at;
                if (itemDate) {
                  const d = new Date(itemDate);
                  return !max || d > max ? d : max;
                }
                return max;
              }, null);
              syncRepo.setLastPullDate(r.entity, maxUpdated ? maxUpdated.toISOString() : new Date().toISOString());
              results.push({ entity: r.entity, success: true, data: r.data, duration: 0 });
            } catch (applyError) {
              syncLogger.error(`   ‚ùå [${r.entity.toUpperCase()}] Erreur application: ${applyError.message}`);
              results.push({ entity: r.entity, success: false, data: [], error: applyError.message, skipped: true });
            }
          } else if (r.success) {
            syncLogger.info(`   ‚ÑπÔ∏è  [${r.entity.toUpperCase()}] Aucune donn√©e (0 item)`);
            syncRepo.setLastPullDate(r.entity, new Date().toISOString());
            results.push({ entity: r.entity, success: true, data: [], duration: 0 });
          } else {
            syncLogger.warn(`   ‚è≠Ô∏è  [${r.entity.toUpperCase()}] Skip: ${r.error || 'Erreur'}`);
            results.push({ entity: r.entity, success: false, data: [], error: r.error, skipped: true });
          }
        }
        
        // Puis les lourds en s√©quentiel (avec timeout court)
        for (const entity of heavyEntities) {
        const entityStartTime = Date.now();
        let attempt = 0;
        
        // Backoff exponentiel : 1s, 2s, 4s, 8s, ... max 60s
        const getRetryDelay = (attemptNum) => {
          const delay = Math.min(60_000, 1000 * Math.pow(2, attemptNum - 1));
          return delay;
        };
        
        while (true) {
          attempt++;
          try {
            const lastSync = isInitialImport ? new Date(0) : syncRepo.getLastPullDate(entity);
            const sinceDate = lastSync ? (typeof lastSync === 'string' ? lastSync : lastSync.toISOString()) : new Date(0).toISOString();
            
            if (attempt === 1) {
              syncLogger.info(`üì• [${entity.toUpperCase()}] D√©but t√©l√©chargement depuis Google Sheets`);
              syncLogger.info(`   üìÖ [${entity.toUpperCase()}] Date 'since' utilis√©e: ${sinceDate} (${new Date(sinceDate).toLocaleString('fr-FR')})`);
              syncLogger.info(`   üîç [${entity.toUpperCase()}] Mode: ${isInitialImport ? 'IMPORT INITIAL (toutes les donn√©es)' : 'SYNC INCR√âMENTALE (depuis lastPullDate)'}`);
            } else {
              syncLogger.info(`üì• [${entity.toUpperCase()}] Tentative ${attempt}${isInitialImport ? ' (retry infini activ√©)' : ''}`);
            }
            
            // Timeout depuis ENV ou valeurs par d√©faut (PRO : utilise les variables d'environnement)
            const envTimeout = parseInt(process.env.SYNC_TIMEOUT_MS || '30000', 10);
            const timeouts = {
              products: isInitialImport ? 60_000 : parseInt(process.env.SHEETS_TIMEOUT_PRODUCTS_MS || envTimeout.toString(), 10),
              sales: isInitialImport ? 60_000 : parseInt(process.env.SHEETS_TIMEOUT_SALES_MS || envTimeout.toString(), 10),
            };
            const timeout = timeouts[entity] || envTimeout;
            syncLogger.info(`   ‚è±Ô∏è  [${entity.toUpperCase()}] Timeout configur√©: ${timeout}ms (${isInitialImport ? 'IMPORT INITIAL' : 'SYNC NORMALE'}) depuis ENV: ${process.env.SYNC_TIMEOUT_MS || 'd√©faut'}`);
            
            const result = await sheetsClient.pull(entity, sinceDate, {
              maxRetries: isInitialImport ? 2 : 1,
              retryDelay: 400,
              timeout: timeout
            });
            
            const pullDuration = Date.now() - entityStartTime;
            
            if (result.success) {
              if (result.data && result.data.length > 0) {
                syncLogger.info(`   ‚úÖ [${entity.toUpperCase()}] ${result.data.length} item(s) t√©l√©charg√©(s) en ${pullDuration}ms`);
                
                // Logs d√©taill√©s pour les ventes (toujours affich√©s pour debug)
                if (entity === 'sales' && result.data.length > 0) {
                  syncLogger.info(`   üìã [SALES] D√©tail des lignes t√©l√©charg√©es depuis Sheets:`);
                  const invoiceCounts = {};
                  result.data.forEach(item => {
                    const inv = item.invoice_number || 'N/A';
                    invoiceCounts[inv] = (invoiceCounts[inv] || 0) + 1;
                  });
                  const uniqueInvoices = Object.keys(invoiceCounts).length;
                  syncLogger.info(`   üìä [SALES] ${result.data.length} ligne(s) ‚Üí ${uniqueInvoices} facture(s) unique(s) d√©tect√©e(s)`);
                  
                  // Afficher les 5 premi√®res factures pour debug
                  result.data.slice(0, 5).forEach((sale, index) => {
                    syncLogger.info(`      [${index + 1}] Facture: ${sale.invoice_number || 'N/A'}, Client: ${sale.client_name || 'N/A'}, Produit: ${sale.product_code || 'N/A'}, Qty: ${sale.qty || 0}`);
                  });
                  if (result.data.length > 5) {
                    syncLogger.info(`      ... et ${result.data.length - 5} autre(s) ligne(s)`);
                  }
                }
                
                // Logs d√©taill√©s pour produits uniquement si VERBOSE
                const VERBOSE = process.env.SYNC_VERBOSE === '1';
                if (VERBOSE && entity === 'products' && result.data.length > 0) {
                  syncLogger.info(`   üìã D√©tail produits: ${result.data.length} produit(s)`);
                  result.data.slice(0, 3).forEach((product, index) => {
                    const unitsCount = product.units ? product.units.length : 0;
                    syncLogger.info(`      [${index + 1}] Code: "${product.code || 'N/A'}", Nom: "${product.name || 'N/A'}", Unit√©s: ${unitsCount}`);
                  });
                }
                
                // APPLIQUER IMM√âDIATEMENT apr√®s t√©l√©chargement r√©ussi (pas d'attente)
                try {
                  const applyStartTime = Date.now();
                  const upsertStats = await this.applyUpdates(entity, result.data);
                  const applyDuration = Date.now() - applyStartTime;
                  
                  syncRepo.setLastPullDate(entity, new Date().toISOString());
                  
                  // Si Products a r√©ussi et c'√©tait un import initial, marquer comme fait
                  if (entity === 'products' && isInitialImport && !syncRepo.isInitialImportDone()) {
                    syncRepo.setInitialImportDone();
                    syncLogger.info(`   üéâ [IMPORT] Import initial termin√© avec succ√®s (${result.data.length} produit(s))`);
                  }
                  
                  // Logs optimis√©s avec d√©tails sp√©cifiques pour les ventes
                  if (upsertStats) {
                    if (entity === 'sales') {
                      syncLogger.info(`   ‚úÖ [SALES] Stockage SQL r√©ussi: ${upsertStats.inserted || 0} facture(s) cr√©√©e(s), ${upsertStats.updated || 0} facture(s) mise(s) √† jour (${applyDuration}ms)`);
                      syncLogger.info(`   üì± [SALES] Les ventes sont maintenant disponibles dans la page "Historique des ventes"`);
                    } else {
                      syncLogger.info(`   ‚úÖ [${entity.toUpperCase()}] ${result.data.length} item(s) ‚Üí SQL: ${upsertStats.inserted || 0} ins√©r√©(s), ${upsertStats.updated || 0} mis √† jour, ${upsertStats.skipped || 0} ignor√©(s) (${applyDuration}ms)`);
                    }
                  } else {
                    syncLogger.info(`   ‚úÖ [${entity.toUpperCase()}] ${result.data.length} item(s) appliqu√©(s) en ${applyDuration}ms`);
                  }
                } catch (applyError) {
                  syncLogger.error(`   ‚ùå [${entity.toUpperCase()}] Erreur application SQL: ${applyError.message}`);
                  // Continuer quand m√™me, on a r√©ussi le t√©l√©chargement
                }
                
                results.push({ entity, success: true, data: result.data, duration: pullDuration });
                break; // Succ√®s, sortir de la boucle de retry
              } else {
                syncLogger.warn(`   ‚ö†Ô∏è  [${entity.toUpperCase()}] Aucune donn√©e retourn√©e (0 item)`);
                syncLogger.warn(`   üîç [${entity.toUpperCase()}] Diagnostic d√©taill√©:`);
                syncLogger.warn(`      - Date 'since' utilis√©e: ${sinceDate} (${new Date(sinceDate).toLocaleString('fr-FR')})`);
                syncLogger.warn(`      - Mode: ${isInitialImport ? 'IMPORT INITIAL (devrait retourner toutes les donn√©es)' : 'SYNC INCR√âMENTALE (seulement les donn√©es modifi√©es depuis lastPullDate)'}`);
                syncLogger.warn(`      - Si sync incr√©mentale: V√©rifier que lastPullDate n'est pas trop r√©cent`);
                syncLogger.warn(`      - Si import initial: V√©rifier que les donn√©es existent dans Google Sheets`);
                syncLogger.warn(`      - ‚ö†Ô∏è  ATTENTION: lastPullDate sera mis √† jour m√™me si 0 items ‚Üí risque de ne jamais r√©cup√©rer les donn√©es`);
                
                // IMPORTANT: Ne pas mettre √† jour lastPullDate si 0 items en sync incr√©mentale
                // (sinon on ne r√©cup√©rera jamais les donn√©es)
                if (!isInitialImport) {
                  syncLogger.warn(`      - ‚è≠Ô∏è  [${entity.toUpperCase()}] Ne pas mettre √† jour lastPullDate (0 items, sync incr√©mentale)`);
                } else {
                  // Pour import initial, mettre √† jour quand m√™me (mais c'est suspect)
                  syncLogger.warn(`      - ‚ö†Ô∏è  [${entity.toUpperCase()}] Import initial avec 0 items - V√©rifier les donn√©es dans Sheets`);
                  syncRepo.setLastPullDate(entity, new Date().toISOString());
                }
                
                results.push({ entity, success: true, data: [], duration: pullDuration });
                break; // Succ√®s (mais vide), sortir de la boucle de retry
              }
            } else {
              // Erreur dans la r√©ponse
              syncLogger.error(`   ‚ùå [${entity.toUpperCase()}] √âchec tentative ${attempt}: ${result.error || 'Erreur inconnue'}`);
              
              // Si import initial, retry infini avec backoff exponentiel
              if (isInitialImport) {
                const delay = getRetryDelay(attempt);
                syncLogger.info(`   üîÑ Retry dans ${delay / 1000}s...`);
                await new Promise(resolve => setTimeout(resolve, delay));
                continue; // R√©essayer ind√©finiment
              } else {
                // Pour sync normale, max 1 tentative (skip rapidement)
                syncLogger.warn(`   ‚è≠Ô∏è  [${entity.toUpperCase()}] Skip apr√®s erreur (sync normale, pas de retry)`);
                syncLogger.warn(`   üí° [${entity.toUpperCase()}] Sera r√©essay√© au prochain cycle de sync (dans 10s)`);
                results.push({ entity, success: false, data: [], error: result.error, duration: Date.now() - entityStartTime, skipped: true });
                break; // Skip imm√©diatement pour sync normale
              }
            }
          } catch (error) {
            const errorDuration = Date.now() - entityStartTime;
            const isTimeout = error.code === 'ECONNABORTED' || error.message?.includes('timeout');
            
            if (isTimeout) {
              syncLogger.warn(`   ‚è±Ô∏è  [${entity.toUpperCase()}] Timeout apr√®s ${(errorDuration / 1000).toFixed(1)}s`);
            } else {
            syncLogger.error(`   ‚ùå [${entity.toUpperCase()}] Erreur tentative ${attempt} apr√®s ${errorDuration}ms: ${error.message}`);
            }
            
            // Si import initial, retry infini avec backoff exponentiel
            if (isInitialImport) {
              const delay = getRetryDelay(attempt);
              syncLogger.info(`   üîÑ Retry dans ${delay / 1000}s...`);
              await new Promise(resolve => setTimeout(resolve, delay));
              continue; // R√©essayer ind√©finiment
            } else {
              // Pour sync normale : skip rapidement si timeout (pas de retry)
              if (isTimeout) {
                syncLogger.warn(`   ‚è≠Ô∏è  [${entity.toUpperCase()}] Skip apr√®s timeout (sync normale, pas de retry)`);
                syncLogger.warn(`   üí° [${entity.toUpperCase()}] Sera r√©essay√© au prochain cycle de sync (dans 10s)`);
                results.push({ entity, success: false, data: [], error: `Timeout apr√®s ${(errorDuration / 1000).toFixed(1)}s`, duration: errorDuration, skipped: true });
                break; // Skip imm√©diatement pour sync normale
              }
              
              // Pour autres erreurs, max 2 tentatives (pas 3)
              if (attempt >= 2) {
                syncLogger.warn(`   ‚è≠Ô∏è  [${entity.toUpperCase()}] Skip apr√®s ${attempt} tentative(s) (sync normale)`);
                results.push({ entity, success: false, data: [], error: error.message, duration: errorDuration, skipped: true });
                break; // √âchec apr√®s 2 tentatives
              }
              const delay = getRetryDelay(attempt);
              syncLogger.info(`   üîÑ Retry dans ${delay / 1000}s...`);
              await new Promise(resolve => setTimeout(resolve, delay));
              continue;
            }
          }
        }
        
          // D√©lai entre chaque entit√© pour ne pas surcharger Apps Script (r√©duit pour rapidit√©)
          if (entity !== heavyEntities[heavyEntities.length - 1]) {
            await new Promise(resolve => setTimeout(resolve, 200)); // 200ms de pause
          }
        }
      }
      
      // R√©sum√© final (les donn√©es ont d√©j√† √©t√© appliqu√©es au fur et √† mesure)
      const totalItems = results.reduce((sum, r) => sum + (r.data?.length || 0), 0);
      const successCount = results.filter(r => r.success).length;
      const failedCount = results.filter(r => !r.success && !r.skipped).length;
      const skippedCount = results.filter(r => r.skipped).length;
      const totalDuration = Date.now() - globalStartTime;
      
      // Compter sp√©cifiquement les ventes pour le r√©sum√©
      const salesResult = results.find(r => r.entity === 'sales');
      const salesCount = salesResult?.data?.length || 0;
      
      syncLogger.info(`‚úÖ [SYNC] Synchronisation termin√©e en ${(totalDuration / 1000).toFixed(1)}s`);
      syncLogger.info(`   üìä [SYNC] R√©sum√© global:`);
      syncLogger.info(`      ‚úÖ ${successCount}/${entities.length} entit√©(s) synchronis√©e(s) avec succ√®s`);
      if (skippedCount > 0) {
        syncLogger.info(`      ‚è≠Ô∏è  ${skippedCount}/${entities.length} entit√©(s) skip√©e(s) (sera r√©essay√© au prochain cycle)`);
      }
      if (failedCount > 0) {
        syncLogger.warn(`      ‚ùå ${failedCount}/${entities.length} entit√©(s) en √©chec`);
      }
      syncLogger.info(`      üì¶ ${totalItems} item(s) t√©l√©charg√©(s) et STOCK√â(S) dans SQLite`);
      if (salesCount > 0 && salesResult?.success) {
        syncLogger.info(`      üí∞ [SALES] ${salesCount} ligne(s) de vente t√©l√©charg√©e(s) depuis Sheets`);
        syncLogger.info(`      üìÑ [SALES] ‚úÖ Ventes stock√©es dans SQLite ‚Üí Disponibles dans la page "Historique des ventes"`);
        syncLogger.info(`      üí° [SALES] Pour voir toutes les ventes: Menu ‚Üí Historique ‚Üí Ajuster les dates (Du/Au)`);
      }
      
      if (skippedCount > 0) {
        results.filter(r => r.skipped).forEach(r => {
          syncLogger.info(`      ‚è≠Ô∏è  ${r.entity}: ${r.error || 'Skip'}`);
        });
        syncLogger.info(`   üîÑ [SYNC] Entit√©s skip√©es seront r√©essay√©es dans ${SYNC_INTERVAL_MS / 1000} secondes`);
      }
      
      if (failedCount > 0) {
        syncLogger.warn(`   ‚ö†Ô∏è  [SYNC] ${failedCount} entit√©(s) n'ont pas pu √™tre synchronis√©e(s)`);
        results.filter(r => !r.success && !r.skipped).forEach(r => {
          syncLogger.warn(`      ‚ùå ${r.entity}: ${r.error || 'Erreur inconnue'}`);
        });
      }
      
      if (totalDuration < 30000) {
        syncLogger.info(`   ‚ö° [SYNC] Synchronisation RAPIDE (< 30s) ‚úÖ`);
      } else {
        syncLogger.warn(`   ‚ö†Ô∏è  [SYNC] Synchronisation lente (${(totalDuration / 1000).toFixed(1)}s) - v√©rifier la connexion`);
      }
      
    } catch (error) {
      syncLogger.error('‚ùå Erreur pullUpdates:', error);
      // Marquer comme hors ligne si erreur r√©seau
      if (error.code === 'ENOTFOUND' || error.code === 'ECONNREFUSED' || error.message?.includes('network') || error.message?.includes('timeout')) {
        isOnline = false;
      }
    }
  }

  /**
   * Applique les mises √† jour r√©cup√©r√©es depuis Sheets
   * @returns {Promise<{inserted: number, updated: number, skipped: number}>} Stats d'upsert
   */
  async applyUpdates(entity, data) {
    const applyStartTime = Date.now();
    try {
      syncLogger.info(`‚öôÔ∏è  [APPLY-UPDATES] ==========================================`);
      syncLogger.info(`‚öôÔ∏è  [APPLY-UPDATES] Application des mises √† jour pour ${entity}`);
      syncLogger.info(`‚öôÔ∏è  [APPLY-UPDATES] ==========================================`);
      syncLogger.info(`   üì¶ Donn√©es re√ßues: ${data ? data.length : 0} item(s)`);
      syncLogger.info(`   üìã Type: ${Array.isArray(data) ? 'Array' : typeof data}`);
      
      // Validation des donn√©es
      if (!data) {
        syncLogger.error(`   ‚ùå [APPLY-UPDATES] ERREUR: data est null ou undefined`);
        return { inserted: 0, updated: 0, skipped: 0 };
      }
      
      if (!Array.isArray(data)) {
        syncLogger.error(`   ‚ùå [APPLY-UPDATES] ERREUR: data n'est pas un tableau (type: ${typeof data})`);
        return { inserted: 0, updated: 0, skipped: 0 };
      }
      
      if (data.length === 0) {
        syncLogger.warn(`   ‚ö†Ô∏è  [APPLY-UPDATES] Aucune donn√©e √† appliquer (tableau vide)`);
        return { inserted: 0, updated: 0, skipped: 0 };
      }
      
      // Log sp√©cial pour les ventes
      if (entity === 'sales') {
        syncLogger.info(`   üîÑ [APPLY-UPDATES] Appel de applySalesUpdates() pour ${data.length} ligne(s) de vente`);
        syncLogger.info(`   üîÑ [APPLY-UPDATES] Les ventes vont √™tre stock√©es dans SQLite (tables: sales + sale_items)`);
        syncLogger.info(`   üìã [APPLY-UPDATES] Exemple de premi√®re ligne: invoice_number="${data[0]?.invoice_number || 'N/A'}", product_code="${data[0]?.product_code || 'N/A'}"`);
      }
      
      let stats = { inserted: 0, updated: 0, skipped: 0 };
      
      switch (entity) {
        case 'products':
        case 'product_units':
          stats = await this.applyProductUpdates(data);
          break;
        case 'sales':
          try {
            stats = await this.applySalesUpdates(data);
            syncLogger.info(`   ‚úÖ [APPLY-UPDATES] applySalesUpdates() termin√© avec succ√®s`);
            syncLogger.info(`      üìä R√©sultat: ${stats.inserted || 0} cr√©√©e(s), ${stats.updated || 0} mise(s) √† jour, ${stats.skipped || 0} ignor√©e(s)`);
            
            // V√©rification automatique post-application pour les ventes
            if (stats.inserted > 0 || stats.updated > 0) {
              syncLogger.info(`   üîç [APPLY-UPDATES] V√©rification automatique post-application...`);
              try {
                const { getDb } = await import('../../db/sqlite.js');
                const db = getDb();
                const salesCount = db.prepare('SELECT COUNT(*) as count FROM sales WHERE origin = ?').get('SHEETS');
                const itemsCount = db.prepare('SELECT COUNT(*) as count FROM sale_items').get();
                syncLogger.info(`      ‚úÖ [VERIFY] Ventes dans SQLite: ${salesCount.count} (origin='SHEETS')`);
                syncLogger.info(`      ‚úÖ [VERIFY] Items dans SQLite: ${itemsCount.count}`);
                
                if (salesCount.count === 0 && (stats.inserted > 0 || stats.updated > 0)) {
                  syncLogger.error(`      ‚ùå [VERIFY] ERREUR: Aucune vente trouv√©e malgr√© ${stats.inserted + stats.updated} traitement(s) r√©ussi(s)`);
                  syncLogger.error(`      üí° [VERIFY] Diagnostic: Les ventes n'ont peut-√™tre pas √©t√© persist√©es en base`);
                } else {
                  syncLogger.info(`      ‚úÖ [VERIFY] V√©rification r√©ussie: Les ventes sont bien pr√©sentes en base`);
                }
              } catch (verifyError) {
                syncLogger.warn(`      ‚ö†Ô∏è  [VERIFY] Erreur lors de la v√©rification automatique: ${verifyError.message}`);
              }
            }
          } catch (salesError) {
            syncLogger.error(`   ‚ùå [APPLY-UPDATES] ERREUR lors de l'application des ventes:`);
            syncLogger.error(`      Message: ${salesError.message || 'Erreur inconnue'}`);
            syncLogger.error(`      Stack: ${salesError.stack?.substring(0, 500)}`);
            throw salesError; // Re-lancer pour √™tre captur√© par le catch externe
          }
          break;
        case 'debts':
          stats = await this.applyDebtsUpdates(data);
          break;
        case 'rates':
          await this.applyRatesUpdates(data);
          stats = { inserted: 0, updated: data.length, skipped: 0 };
          break;
        case 'users':
          await this.applyUsersUpdates(data);
          stats = { inserted: 0, updated: data.length, skipped: 0 };
          break;
        default:
          syncLogger.warn(`‚ö†Ô∏è  [APPLY-UPDATES] Type d'entit√© non g√©r√©: ${entity}`);
          stats = { inserted: 0, updated: 0, skipped: 0 };
      }
      
      const applyDuration = Date.now() - applyStartTime;
      syncLogger.info(`‚úÖ [APPLY-UPDATES] Application termin√©e en ${applyDuration}ms`);
      syncLogger.info(`   üìä R√©sultat final: ${stats.inserted || 0} ins√©r√©(s), ${stats.updated || 0} mis √† jour, ${stats.skipped || 0} ignor√©(s)`);
      syncLogger.info(`‚öôÔ∏è  [APPLY-UPDATES] ==========================================`);
      
      return stats;
    } catch (error) {
      const applyDuration = Date.now() - applyStartTime;
      syncLogger.error(`‚ùå [APPLY-UPDATES] ERREUR lors de l'application pour ${entity} (apr√®s ${applyDuration}ms):`);
      syncLogger.error(`   Message: ${error.message || 'Erreur inconnue'}`);
      syncLogger.error(`   Stack: ${error.stack?.substring(0, 500)}`);
      syncLogger.error(`‚öôÔ∏è  [APPLY-UPDATES] ==========================================`);
      throw error;
    }
  }

  /**
   * Applique les mises √† jour de produits
   * @returns {Promise<{inserted: number, updated: number, skipped: number}>} Stats d'upsert
   */
  async applyProductUpdates(data) {
    const startTime = Date.now();
    
    if (!data || data.length === 0) {
      syncLogger.warn('‚ö†Ô∏è  [PRODUCTS] Aucune donn√©e produit √† appliquer');
      return;
    }

    syncLogger.info(`üì¶ [PRODUCTS] D√©but application de ${data.length} item(s) dans SQLite...`);
    syncLogger.info(`   üíæ [SQL] Tables: products + product_units, Op√©ration: INSERT/UPDATE`);
    syncLogger.info(`   üìä [SQL] Type de donn√©es: ${Array.isArray(data) ? 'array' : typeof data}, ${data.length} ligne(s) √† traiter`);
    
    if (data.length > 0) {
      syncLogger.info(`   üîç [SQL] Premier item: ${JSON.stringify(data[0]).substring(0, 200)}...`);
    }

    // Grouper les produits par code
    const productsByCode = {};
    let itemsSkipped = 0;
    let itemsWithoutCode = 0;
    let itemsWithoutUnitLevel = 0;
    
    for (let i = 0; i < data.length; i++) {
      const item = data[i];
      // Normaliser le code : trim et convertir en string
      let code = item.code;
      if (code) {
        code = String(code).trim();
      }
      
      if (!code || code === '' || code === 'undefined' || code === 'null') {
        itemsSkipped++;
        itemsWithoutCode++;
        syncLogger.warn(`   ‚ö†Ô∏è  Item ${i+1}/${data.length} ignor√©: code vide ou invalide (code="${item.code}")`);
        if (i < 5) { // Log les 5 premiers items ignor√©s pour diagnostic
          syncLogger.warn(`      D√©tail item ignor√©: ${JSON.stringify(item).substring(0, 200)}`);
        }
        continue;
      }
      
      syncLogger.debug(`   üìù Item ${i+1}/${data.length}: code="${code}", name="${item.name || 'N/A'}", unit_level="${item.unit_level || 'N/A'}"`);
      
      // Si l'item a une propri√©t√© 'units', c'est un produit avec ses unit√©s (format de getProductsSince pour 'products')
      if (item.units && Array.isArray(item.units)) {
        // Format: { code, name, uuid, units: [...] }
        if (!productsByCode[code]) {
          productsByCode[code] = {
            code: code,
            name: item.name || '',
            uuid: item.uuid,
            units: []
          };
        }
        
        // Ajouter toutes les unit√©s du produit
        // IMPORTANT: Ignorer sale_price_fc venant de Sheets, utiliser seulement sale_price_usd
        for (const unit of item.units) {
          productsByCode[code].units.push({
            uuid: unit.uuid,
            unit_level: unit.unit_level || 'PIECE',
            unit_mark: unit.unit_mark || '',
            stock_initial: unit.stock_initial || unit.stock_current || 0,
            stock_current: unit.stock_current || unit.stock_initial || 0,
            purchase_price_usd: unit.purchase_price_usd || 0,
            // sale_price_fc sera calcul√© automatiquement depuis sale_price_usd dans products.repo.js
            sale_price_usd: unit.sale_price_usd || 0,
            auto_stock_factor: unit.auto_stock_factor || 1,
            qty_step: unit.qty_step || 1,
            last_update: unit.last_update || new Date().toISOString()
          });
        }
      } else if (item.unit_level) {
        // Format: unit√© individuelle (format de getProductsPage/getProductsSince pour 'product_units')
        if (!productsByCode[code]) {
          productsByCode[code] = {
            code: code,
            name: item.name || '',
            uuid: item.uuid,
            units: []
          };
        }
        
        productsByCode[code].units.push({
          uuid: item.uuid,
          unit_level: item.unit_level || 'PIECE',
          unit_mark: item.unit_mark || '',
          stock_initial: item.stock_initial || item.stock_current || 0,
          stock_current: item.stock_current || item.stock_initial || 0,
          purchase_price_usd: item.purchase_price_usd || 0,
          // sale_price_fc sera calcul√© automatiquement depuis sale_price_usd dans products.repo.js
          sale_price_usd: item.sale_price_usd || 0,
          auto_stock_factor: item.auto_stock_factor || 1,
          qty_step: item.qty_step || 1,
          last_update: item.last_update || new Date().toISOString()
        });
      } else {
        // Item sans unit_level - on l'ajoute quand m√™me avec PIECE par d√©faut
        itemsWithoutUnitLevel++;
        syncLogger.warn(`   ‚ö†Ô∏è  Item ${i+1}/${data.length} sans unit_level, utilisation de PIECE par d√©faut (code="${code}")`);
        
        if (!productsByCode[code]) {
          productsByCode[code] = {
            code: code,
            name: item.name || '',
            uuid: item.uuid,
            units: []
          };
        }
        
        productsByCode[code].units.push({
          uuid: item.uuid,
          unit_level: 'PIECE',
          unit_mark: item.unit_mark || '',
          stock_initial: item.stock_initial || item.stock_current || 0,
          stock_current: item.stock_current || item.stock_initial || 0,
          purchase_price_usd: item.purchase_price_usd || 0,
          // sale_price_fc sera calcul√© automatiquement depuis sale_price_usd dans products.repo.js
          sale_price_usd: item.sale_price_usd || 0,
          auto_stock_factor: item.auto_stock_factor || 1,
          qty_step: item.qty_step || 1,
          last_update: item.last_update || new Date().toISOString()
        });
      }
    }
    
    syncLogger.info(`   üìä Groupement termin√©: ${Object.keys(productsByCode).length} produit(s) unique(s) trouv√©(s)`);
    syncLogger.info(`   ‚è≠Ô∏è  Items ignor√©s: ${itemsSkipped} (${itemsWithoutCode} sans code, ${itemsWithoutUnitLevel} sans unit_level)`);
    
    if (itemsSkipped > 0 && itemsSkipped === data.length) {
      syncLogger.error(`   ‚ùå CRITIQUE: TOUS les items ont √©t√© ignor√©s ! V√©rifier que les colonnes "Code produit" dans Sheets (Carton/Milliers/Piece) sont bien remplies.`);
      syncLogger.error(`   üí° Solution: V√©rifier dans Google Sheets que chaque ligne a un code produit valide dans la colonne "Code produit"`);
    }
    
    // Ins√©rer ou mettre √† jour chaque produit
    let insertedCount = 0;
    let updatedCount = 0;
    let skippedPendingCount = 0;
    let errorCount = 0;
    const upsertStartTime = Date.now();
    
    for (const code in productsByCode) {
      try {
        const product = productsByCode[code];
        syncLogger.info(`   üíæ [${code}] Upsert produit "${product.name || 'sans nom'}" avec ${product.units.length} unit√©(s)`);
        
        // V√©rifier si le produit existe d√©j√†
        const existing = productsRepo.findByCode(code);
        const isNew = !existing;
        
        // R√àGLE CRITIQUE: Ne pas √©craser un produit/unit√© en pending (modifications locales non synchronis√©es)
        // Utiliser le nouveau syst√®me d'outbox pour v√©rifier les op√©rations pending
        const hasProductPending = outboxRepo.hasProductPending(code);
        
        if (hasProductPending && !isNew) {
          // Le produit existe et a des modifications locales en pending
          // Ne pas √©craser les modifications locales
          skippedPendingCount++;
          syncLogger.warn(`      ‚è∏Ô∏è  Produit "${code}" IGNOR√â (modifications locales en pending)`);
          syncLogger.warn(`         üí° Les modifications locales seront synchronis√©es vers Sheets avant d'accepter les mises √† jour depuis Sheets`);
          continue;
        }
        
        // Pour chaque unit√©, v√©rifier si elle a des mouvements de stock pending
        // Si des mouvements pending existent, on doit pr√©server le stock local
        // et appliquer les deltas pending sur le stock Sheets
        const unitsToUpsert = [];
        for (const unit of product.units) {
          // V√©rifier si l'unit√© a des mouvements de stock pending
          const hasStockPending = outboxRepo.hasStockMovePending(code, unit.unit_level, unit.unit_mark);
          
          if (hasStockPending && !isNew) {
            // R√àGLE IMPORTANTE: Stock ne doit jamais √™tre √©cras√© si des mouvements pending existent
            // On doit recalculer le stock correct en appliquant les deltas pending sur le stock Sheets
            const existingUnit = existing?.units?.find(
              u => u.unit_level === unit.unit_level && u.unit_mark === unit.unit_mark
            );
            
            if (existingUnit) {
              // R√©cup√©rer le total des deltas pending
              const pendingDelta = outboxRepo.getPendingStockDelta(code, unit.unit_level, unit.unit_mark);
              
              // Le stock correct = stock Sheets + deltas pending locaux
              // Car les deltas locaux n'ont pas encore √©t√© appliqu√©s c√¥t√© Sheets
              const correctedStock = (unit.stock_current || 0) + pendingDelta;
              
              syncLogger.warn(`      ‚è∏Ô∏è  Unit√© "${unit.unit_level}/${unit.unit_mark}" a des mouvements stock pending`);
              syncLogger.warn(`         üìä Stock Sheets: ${unit.stock_current}, Deltas pending: ${pendingDelta > 0 ? '+' : ''}${pendingDelta}`);
              syncLogger.warn(`         üìä Stock corrig√©: ${correctedStock} (sera utilis√©)`);
              
              unitsToUpsert.push({
                ...unit,
                stock_current: correctedStock,
                stock_initial: correctedStock
              });
            } else {
              // Unit√© nouvelle, utiliser les donn√©es de Sheets
              unitsToUpsert.push(unit);
            }
          } else {
            // V√©rifier aussi les patches d'unit√© en pending (prix, etc.)
            const hasUnitPatchPending = syncRepo.isUnitPending(code, unit.unit_level, unit.unit_mark);
            
            if (hasUnitPatchPending && !isNew) {
              const existingUnit = existing?.units?.find(
                u => u.unit_level === unit.unit_level && u.unit_mark === unit.unit_mark
              );
              
              if (existingUnit) {
                // Pr√©server les prix locaux si en pending
                syncLogger.warn(`      ‚è∏Ô∏è  Unit√© "${unit.unit_level}/${unit.unit_mark}" a des modifications pending`);
                syncLogger.warn(`         üí∞ Prix local pr√©serv√©: ${existingUnit.sale_price_usd} USD`);
                unitsToUpsert.push({
                  ...unit,
                  sale_price_usd: existingUnit.sale_price_usd, // Pr√©server le prix local
                  purchase_price_usd: existingUnit.purchase_price_usd,
                  stock_current: existingUnit.stock_current, // Pr√©server le stock local aussi
                  stock_initial: existingUnit.stock_initial || existingUnit.stock_current
                });
              } else {
                unitsToUpsert.push(unit);
              }
            } else {
              // Aucune op√©ration pending, utiliser les donn√©es de Sheets normalement
              unitsToUpsert.push(unit);
            }
          }
        }
        
        const upsertItemStart = Date.now();
        productsRepo.upsert({
          ...product,
          units: unitsToUpsert,
          is_active: 1,
          _origin: 'SHEETS'
        });
        const upsertItemDuration = Date.now() - upsertItemStart;
        
        if (isNew) {
          insertedCount++;
          syncLogger.info(`      ‚úÖ Produit "${code}" INS√âR√â en ${upsertItemDuration}ms`);
        } else {
          updatedCount++;
          syncLogger.info(`      ‚úÖ Produit "${code}" MIS √Ä JOUR en ${upsertItemDuration}ms`);
        }
      } catch (error) {
        errorCount++;
        syncLogger.error(`      ‚ùå Erreur upsert produit ${code}:`);
        syncLogger.error(`         Message: ${error.message}`);
        syncLogger.error(`         Stack: ${error.stack?.substring(0, 300)}`);
      }
    }
    
    const totalDuration = Date.now() - startTime;
    syncLogger.info(`‚úÖ [PRODUCTS] Application SQL termin√©e en ${totalDuration}ms`);
    syncLogger.info(`   üìä [SQL] R√©sum√© SQL:`);
    syncLogger.info(`      ‚úÖ ${insertedCount} produit(s) INS√âR√â(S) (INSERT INTO products + product_units)`);
    syncLogger.info(`      ‚úÖ ${updatedCount} produit(s) MIS √Ä JOUR (UPDATE products + product_units)`);
    if (skippedPendingCount > 0) {
      syncLogger.info(`      ‚è∏Ô∏è  ${skippedPendingCount} produit(s) IGNOR√â(S) (modifications locales en pending)`);
    }
    syncLogger.info(`      ‚ùå ${errorCount} produit(s) EN ERREUR`);
    syncLogger.info(`   ‚è±Ô∏è  [SQL] Temps moyen par produit: ${(insertedCount + updatedCount) > 0 ? Math.round(totalDuration / (insertedCount + updatedCount)) : 0}ms`);
    
    if (insertedCount + updatedCount > 0) {
      syncLogger.info(`   üéâ [SQL] ${insertedCount + updatedCount} produit(s) maintenant STOCK√â(S) dans SQLite et DISPONIBLE(S) dans la page Produits!`);
      syncLogger.info(`   üìä [SQL] V√©rification: SELECT COUNT(*) FROM products WHERE is_active = 1; devrait retourner au moins ${insertedCount + updatedCount} ligne(s)`);
    }
    
    return { inserted: insertedCount, updated: updatedCount, skipped: skippedPendingCount };
  }

  /**
   * Applique les mises √† jour de ventes
   * @returns {Promise<{inserted: number, updated: number, skipped: number}>} Stats d'upsert
   */
  async applySalesUpdates(data) {
    const startTime = Date.now();
    syncLogger.info(`üí∞ [SALES] ==========================================`);
    syncLogger.info(`üí∞ [SALES] D√âBUT SYNCHRONISATION DES VENTES`);
    syncLogger.info(`üí∞ [SALES] ==========================================`);
    syncLogger.info(`   üì• SOURCE: Google Sheets (feuille "Ventes")`);
    syncLogger.info(`   üì¶ R√âCEPTION: ${data.length} ligne(s) t√©l√©charg√©e(s) depuis Sheets`);
    syncLogger.info(`   üîÑ DESTINATION: Base de donn√©es SQLite locale (tables: sales + sale_items)`);
    syncLogger.info(`üí∞ [SALES] ==========================================`);
    
    // V√©rification initiale du nombre de ventes dans SQLite AVANT traitement
    let salesCountBefore = 0;
    let itemsCountBefore = 0;
    try {
      const { getDb } = await import('../../db/sqlite.js');
      const db = getDb();
      const salesCountResult = db.prepare('SELECT COUNT(*) as count FROM sales WHERE origin = ?').get('SHEETS');
      const itemsCountResult = db.prepare('SELECT COUNT(*) as count FROM sale_items').get();
      salesCountBefore = salesCountResult?.count || 0;
      itemsCountBefore = itemsCountResult?.count || 0;
      syncLogger.info(`   üîç [SALES] √âTAT INITIAL SQLite: ${salesCountBefore} vente(s) avec origin='SHEETS', ${itemsCountBefore} item(s)`);
    } catch (initError) {
      syncLogger.error(`   ‚ùå [SALES] Erreur lors de la v√©rification initiale: ${initError.message}`);
      syncLogger.error(`   üìã [SALES] Stack: ${initError.stack?.substring(0, 500)}`);
    }
    
    if (!data || data.length === 0) {
      syncLogger.warn(`‚ö†Ô∏è  [SALES] Aucune donn√©e vente √† appliquer dans SQLite`);
      syncLogger.warn(`   üí° [SALES] V√©rifier que la feuille "Ventes" contient des donn√©es dans Google Sheets`);
      syncLogger.warn(`   üîç [SALES] Diagnostic: data=${data ? 'existe mais vide' : 'null/undefined'}, length=${data?.length || 0}`);
      return { inserted: 0, updated: 0, skipped: 0 };
    }
    
    // Log d√©taill√© des premi√®res lignes pour diagnostic
    syncLogger.info(`   üìã [SALES] Analyse des donn√©es re√ßues:`);
    syncLogger.info(`      ‚úÖ Type: ${Array.isArray(data) ? 'Array' : typeof data}`);
    syncLogger.info(`      ‚úÖ Longueur: ${data.length} ligne(s)`);
    if (data.length > 0) {
      const firstItem = data[0];
      syncLogger.info(`      üìã [SALES] Premier item (√©chantillon):`);
      syncLogger.info(`         - invoice_number: ${firstItem.invoice_number || 'MANQUANT'}`);
      syncLogger.info(`         - client_name: ${firstItem.client_name || 'N/A'}`);
      syncLogger.info(`         - product_code: ${firstItem.product_code || 'N/A'}`);
      syncLogger.info(`         - qty: ${firstItem.qty !== undefined ? firstItem.qty : 'MANQUANT'}`);
      syncLogger.info(`         - uuid: ${firstItem.uuid || 'MANQUANT'}`);
      syncLogger.info(`         - sold_at: ${firstItem.sold_at || 'MANQUANT'}`);
    }
    
    syncLogger.info(`   üì• [SALES] ${data.length} ligne(s) re√ßue(s) depuis Google Sheets (feuille "Ventes")`);
    syncLogger.info(`   üîÑ [SALES] SYNCHRONISATION EN COURS: Sheets ‚Üí SQLite local`);
    syncLogger.info(`   üìã [SALES] Structure des donn√©es:`);
    if (data.length > 0) {
      const firstItem = data[0];
      syncLogger.info(`      ‚úÖ invoice_number: ${firstItem.invoice_number ? '‚úì' : '‚úó'}`);
      syncLogger.info(`      ‚úÖ client_name: ${firstItem.client_name ? '‚úì' : '‚úó'}`);
      syncLogger.info(`      ‚úÖ product_code: ${firstItem.product_code ? '‚úì' : '‚úó'}`);
      syncLogger.info(`      ‚úÖ qty: ${firstItem.qty !== undefined ? '‚úì' : '‚úó'}`);
      syncLogger.info(`      ‚úÖ unit_price_fc: ${firstItem.unit_price_fc !== undefined ? '‚úì' : '‚úó'}`);
      syncLogger.info(`      ‚úÖ uuid: ${firstItem.uuid ? '‚úì' : '‚úó'}`);
    }
    
    // Grouper les lignes par facture (une facture peut avoir plusieurs lignes)
    const salesByInvoice = {};
    let skippedLinesCount = 0;
    
    for (let i = 0; i < data.length; i++) {
      const item = data[i];
      const invoiceNumber = item.invoice_number;
      
      if (!invoiceNumber || invoiceNumber.toString().trim() === '') {
        skippedLinesCount++;
        if (i < 5) { // Log les 5 premiers pour debug
          syncLogger.warn(`   ‚ö†Ô∏è  [SALES] Ligne ${i + 1}/${data.length} ignor√©e: pas de num√©ro de facture`);
        }
        continue;
      }
      
      if (!salesByInvoice[invoiceNumber]) {
        salesByInvoice[invoiceNumber] = {
          uuid: null, // UUID de la vente (sera r√©cup√©r√© depuis la premi√®re ligne ou g√©n√©r√©)
          invoice_number: invoiceNumber,
          sold_at: item.sold_at,
          client_name: item.client_name || '',
          client_phone: item.client_phone || '',
          seller_name: item.seller_name || '',
          items: []
        };
        syncLogger.debug(`   üìã [SALES] Nouvelle facture d√©tect√©e: ${invoiceNumber}`);
      }
      
      // Utiliser le UUID de la premi√®re ligne si disponible (pour la vente elle-m√™me)
      // Note: Chaque item peut avoir son propre UUID, mais la vente (sales) a aussi un UUID
      if (!salesByInvoice[invoiceNumber].uuid && item._sale_uuid) {
        salesByInvoice[invoiceNumber].uuid = item._sale_uuid;
      }
      
      // Trouver le product_id depuis le code produit
      let product = null;
      let productName = item.product_name || '';
      if (item.product_code) {
        product = productsRepo.findByCode(item.product_code);
        if (product && !productName) {
          productName = product.name || '';
        }
        if (!product) {
          syncLogger.debug(`   ‚ö†Ô∏è  [SALES] Produit non trouv√© localement: code="${item.product_code}" (sera stock√© avec product_id=null)`);
        }
      }
      
      // Normaliser l'unit√© depuis Sheets (colonne H = unit√© r√©elle)
      // IMPORTANT: Utiliser l'unit√© de Sheets telle quelle, ne pas la remplacer par celle du produit
      let unitLevel = null;
      let unitLevelFromSheets = null; // Conserver l'unit√© originale de Sheets
      
      // R√©cup√©rer l'unit√© depuis Sheets (peut √™tre dans unit_level ou vide)
      const rawUnit = item.unit_level ? String(item.unit_level).trim() : '';
      
      if (rawUnit) {
        // Log toujours pour diagnostiquer les probl√®mes d'unit√©
        syncLogger.info(`   üîç [SALES] Unit√© brute depuis Sheets: "${rawUnit}" pour produit ${item.product_code} (facture: ${invoiceNumber})`);
        
        // Normaliser l'unit√© depuis Sheets (peut √™tre "millier", "carton", "piece" en minuscules)
        unitLevelFromSheets = normalizeUnitFromSheets(rawUnit);
        
        if (!unitLevelFromSheets) {
          // Si normalisation √©choue, utiliser la valeur telle quelle (peut √™tre d√©j√† normalis√©e)
          const upperValue = rawUnit.toUpperCase();
          // V√©rifier que c'est une valeur valide
          if (upperValue === 'MILLIER' || upperValue === 'CARTON' || upperValue === 'PIECE' || upperValue === 'MILLIERS') {
            unitLevelFromSheets = upperValue === 'MILLIERS' ? 'MILLIER' : upperValue;
            syncLogger.info(`   ‚úÖ [SALES] Unit√© normalis√©e depuis majuscules: "${unitLevelFromSheets}" pour produit ${item.product_code}`);
          } else {
            syncLogger.warn(`   ‚ö†Ô∏è [SALES] Unit√© non reconnue depuis Sheets: "${rawUnit}" (upper: "${upperValue}") pour produit ${item.product_code}`);
          }
        } else {
          syncLogger.info(`   ‚úÖ [SALES] Unit√© normalis√©e depuis Sheets: "${unitLevelFromSheets}" (brut: "${rawUnit}") pour produit ${item.product_code}`);
        }
      } else {
        syncLogger.warn(`   ‚ö†Ô∏è [SALES] Pas d'unit√© dans Sheets pour produit ${item.product_code} (facture: ${invoiceNumber}) - item.unit_level="${item.unit_level}"`);
      }
      
      // Utiliser l'unit√© de Sheets si elle est valide (PRIORITAIRE - ne jamais remplacer)
      if (unitLevelFromSheets) {
        unitLevel = unitLevelFromSheets;
        syncLogger.info(`   ‚úÖ [SALES] Unit√© depuis Sheets: "${unitLevel}" pour produit ${item.product_code} (PR√âSERV√âE)`);
      }
      
      let unitMark = item.unit_mark || '';
      
      // Si unitLevel n'est pas sp√©cifi√© dans Sheets, chercher dans le produit
      if (!unitLevel && product?.id && product.units && product.units.length > 0) {
        // Utiliser la premi√®re unit√© disponible du produit
        const foundUnit = product.units[0];
        unitLevel = foundUnit.unit_level;
        unitMark = foundUnit.unit_mark || '';
        syncLogger.debug(`   üîç [SALES] Unit√© non sp√©cifi√©e dans Sheets, utilisation de la premi√®re unit√© disponible "${unitLevel}/${unitMark}" pour produit ${item.product_code}`);
      } else if (unitLevel && product?.id && product.units && product.units.length > 0) {
        // Chercher l'unit√© exacte dans le produit pour r√©cup√©rer le unit_mark si n√©cessaire
        let foundUnit = product.units.find(
          u => u.unit_level === unitLevel && u.unit_mark === unitMark
        );
        
        // Si pas trouv√©e exactement, chercher une unit√© avec le m√™me unit_level pour r√©cup√©rer le mark
        if (!foundUnit) {
          foundUnit = product.units.find(u => u.unit_level === unitLevel);
          if (foundUnit && !unitMark) {
            // Utiliser le mark du produit seulement si pas de mark dans Sheets
            unitMark = foundUnit.unit_mark || '';
            syncLogger.debug(`   üîç [SALES] Mark r√©cup√©r√© depuis produit: "${unitMark}" pour unit√© "${unitLevel}" du produit ${item.product_code}`);
          }
        } else {
          // Utiliser le mark du produit si trouv√©
          unitMark = foundUnit.unit_mark || unitMark;
        }
        
        // IMPORTANT: Ne PAS remplacer unitLevel par celle du produit si elle vient de Sheets
        // L'unit√© de Sheets est la source de v√©rit√© pour les ventes historiques
      }
      
      // Fallback final: si toujours pas d'unit√©, utiliser PIECE (seulement en dernier recours)
      if (!unitLevel) {
        unitLevel = 'PIECE';
        syncLogger.warn(`   ‚ö†Ô∏è  [SALES] Aucune unit√© trouv√©e pour produit ${item.product_code}, utilisation de PIECE par d√©faut`);
      }
      
      // V√âRIFICATION FINALE: S'assurer que l'unit√© de Sheets est pr√©serv√©e
      // Si unitLevelFromSheets existe, l'utiliser m√™me si le produit n'a pas cette unit√©
      if (unitLevelFromSheets && unitLevel !== unitLevelFromSheets) {
        syncLogger.warn(`   ‚ö†Ô∏è [SALES] CORRECTION: Unit√© remplac√©e incorrectement, restauration de "${unitLevelFromSheets}" pour produit ${item.product_code}`);
        unitLevel = unitLevelFromSheets;
      }
      
      // Calculer subtotal si non fourni
      const qty = item.qty || 0;
      const unitPriceFC = item.unit_price_fc || 0;
      const unitPriceUSD = item.unit_price_usd || 0;
      const subtotalFC = item.subtotal_fc !== undefined ? item.subtotal_fc : (qty * unitPriceFC);
      const subtotalUSD = item.subtotal_usd !== undefined ? item.subtotal_usd : (qty * unitPriceUSD);
      
      syncLogger.debug(`   üìù [SALES] Item final: produit=${item.product_code}, unit√©="${unitLevel}", mark="${unitMark}", qty=${qty}`);
      
      // IMPORTANT: S'assurer que product_id est d√©fini avant d'ajouter l'item
      // Si le produit n'existe pas, on ne peut pas cr√©er l'item (erreur de validation)
      if (!product?.id) {
        syncLogger.warn(`   ‚ö†Ô∏è [SALES] Produit non trouv√© pour code "${item.product_code}" (facture: ${invoiceNumber}) - item ignor√©`);
        skippedLinesCount++;
        continue; // Ignorer cet item
      }
      
      salesByInvoice[invoiceNumber].items.push({
        uuid: item.uuid || null, // UUID de l'item de vente (sale_items)
        product_id: product.id, // IMPORTANT: Toujours d√©fini (v√©rifi√© ci-dessus)
        product_code: item.product_code || '',
        product_name: productName,
        unit_level: unitLevel, // IMPORTANT: Utiliser l'unit√© de Sheets (pr√©serv√©e)
        unit_mark: unitMark,
        qty: qty,
        qty_label: item.qty_label || (qty ? qty.toString() : '0'),
        unit_price_fc: unitPriceFC,
        subtotal_fc: subtotalFC,
        unit_price_usd: unitPriceUSD,
        subtotal_usd: subtotalUSD
      });
      
      // Utiliser les donn√©es de la derni√®re ligne pour les m√©tadonn√©es de la vente
      // (client_name, client_phone, seller_name peuvent varier entre lignes, on prend la derni√®re)
      if (item.client_name) salesByInvoice[invoiceNumber].client_name = item.client_name;
      if (item.client_phone) salesByInvoice[invoiceNumber].client_phone = item.client_phone;
      if (item.seller_name) salesByInvoice[invoiceNumber].seller_name = item.seller_name;
      if (item.sold_at) salesByInvoice[invoiceNumber].sold_at = item.sold_at;
    }
    
    if (skippedLinesCount > 0) {
      syncLogger.warn(`   ‚ö†Ô∏è  [SALES] ${skippedLinesCount} ligne(s) ignor√©e(s) (sans num√©ro de facture)`);
    }
    
    const uniqueInvoicesCount = Object.keys(salesByInvoice).length;
    syncLogger.info(`   üìä [SALES] GROUPEMENT: ${data.length} ligne(s) ‚Üí ${uniqueInvoicesCount} facture(s) unique(s)`);
    
    let insertedCount = 0;
    let updatedCount = 0;
    let skippedCount = 0;
    let errorCount = 0;
    
    // Traiter chaque facture
    let invoiceIndex = 0;
    for (const invoiceNumber in salesByInvoice) {
      invoiceIndex++;
      try {
        const saleData = salesByInvoice[invoiceNumber];
        
        syncLogger.info(`   üîÑ [SALES] Traitement facture #${invoiceIndex}/${uniqueInvoicesCount}: ${invoiceNumber}`);
        syncLogger.info(`      üìã Items: ${saleData.items.length}, Client: ${saleData.client_name || 'N/A'}`);
        
        // Calculer les totaux de la facture
        let totalFC = 0;
        let totalUSD = 0;
        for (const item of saleData.items) {
          totalFC += item.subtotal_fc || 0;
          totalUSD += item.subtotal_usd || 0;
        }
        
        syncLogger.info(`      üí∞ Total FC: ${totalFC.toLocaleString()}, Total USD: ${totalUSD.toLocaleString()}`);
        
        // V√©rifier si la vente existe d√©j√† dans SQLite
        const existing = salesRepo.findByInvoice(invoiceNumber);
        const isNew = !existing;
        
        syncLogger.info(`      üîç [SALES] Recherche dans SQLite: ${isNew ? 'Nouvelle facture (sera cr√©√©e)' : 'Facture existante trouv√©e (sera mise √† jour si n√©cessaire)'}`);
        
        // IMPORTANT: Toujours mettre √† jour les ventes depuis Sheets pour s'assurer que les unit√©s sont correctes
        // M√™me si la vente existe d√©j√†, on la met √† jour pour garantir la coh√©rence avec Sheets
        if (existing) {
          const existingTotalFC = existing.total_fc || 0;
          const existingItemsCount = existing.items ? existing.items.length : 0;
          
          // V√©rifier si les unit√©s ont chang√© (comparer les unit_level des items)
          let unitsChanged = false;
          if (existing.items && existing.items.length === saleData.items.length) {
            for (let i = 0; i < existing.items.length; i++) {
              const existingItem = existing.items[i];
              const newItem = saleData.items[i];
              if (existingItem.unit_level !== newItem.unit_level) {
                unitsChanged = true;
                syncLogger.info(`   üîç [SALES] Unit√© chang√©e pour item ${i+1}: "${existingItem.unit_level}" ‚Üí "${newItem.unit_level}"`);
                break;
              }
            }
          }
          
          const hasChanges = Math.abs(existingTotalFC - totalFC) > 0.01 || 
                            existingItemsCount !== saleData.items.length ||
                            unitsChanged;
          
          // Toujours mettre √† jour pour s'assurer que les unit√©s sont correctes
          // M√™me si les donn√©es semblent identiques, Sheets est la source de v√©rit√©
          syncLogger.info(`   üîÑ [SALES] Facture ${invoiceNumber} existe ‚Üí MISE √Ä JOUR FORC√âE (Sheets = source de v√©rit√©)`);
          if (hasChanges) {
            syncLogger.debug(`      üìä Changements d√©tect√©s: Total FC ${existingTotalFC} ‚Üí ${totalFC}, Items ${existingItemsCount} ‚Üí ${saleData.items.length}, Unit√©s chang√©es: ${unitsChanged}`);
          } else {
            syncLogger.debug(`      üìä Pas de changements d√©tect√©s mais mise √† jour forc√©e pour garantir la coh√©rence des unit√©s`);
          }
        }
        
        // G√©n√©rer UUID pour la vente si non fourni
        if (!saleData.uuid) {
          saleData.uuid = existing?.uuid || generateUUID();
        }
        
        syncLogger.info(`   üí∞ [SALES] Facture ${invoiceNumber}: ${isNew ? 'CR√âATION' : 'MISE √Ä JOUR'}`);
        syncLogger.info(`      üìã Client: ${saleData.client_name || 'N/A'}, Vendeur: ${saleData.seller_name || 'N/A'}`);
        syncLogger.info(`      üì¶ ${saleData.items.length} article(s), Total: ${totalFC.toLocaleString()} FC`);
        syncLogger.info(`      üíæ [SQL] ${isNew ? 'INSERT' : 'UPDATE'} dans SQLite (table: sales + sale_items)`);
        syncLogger.info(`      üì• [SQL] Source: Google Sheets ‚Üí Local SQLite`);
        
        // Validation des donn√©es avant upsert
        if (!saleData.sold_at) {
          syncLogger.warn(`      ‚ö†Ô∏è  [SALES] ATTENTION: Facture ${invoiceNumber} sans date (sold_at) - utilisation de la date actuelle`);
          saleData.sold_at = new Date().toISOString();
        }
        
        // Utiliser upsert (qui ne d√©cr√©mente PAS le stock car vente d√©j√† effectu√©e dans Sheets)
        syncLogger.info(`      üîÑ [SQL] Appel salesRepo.upsert() pour facture ${invoiceNumber}...`);
        syncLogger.info(`         üìã Donn√©es √† stocker: ${saleData.items.length} item(s), Total FC: ${totalFC}, Total USD: ${totalUSD}`);
        syncLogger.info(`         üîç [SQL] UUID vente: ${saleData.uuid || 'sera g√©n√©r√©'}`);
        syncLogger.info(`         üîç [SQL] Date vente: ${saleData.sold_at}`);
        
        const upsertStartTime = Date.now();
        let savedSale = null;
        let upsertError = null;
        
        try {
          savedSale = salesRepo.upsert({
            uuid: saleData.uuid,
            invoice_number: invoiceNumber,
            sold_at: saleData.sold_at,
            client_name: saleData.client_name,
            client_phone: saleData.client_phone,
            seller_name: saleData.seller_name,
            total_fc: totalFC,
            total_usd: totalUSD,
            payment_mode: 'cash',
            status: 'paid',
            origin: 'SHEETS',
            rate_fc_per_usd: 2800, // Par d√©faut
            items: saleData.items
          });
        } catch (error) {
          upsertError = error;
          syncLogger.error(`      ‚ùå [SQL] ERREUR lors de l'upsert de la facture ${invoiceNumber}:`);
          syncLogger.error(`         Message: ${error.message || 'Erreur inconnue'}`);
          syncLogger.error(`         Stack: ${error.stack?.substring(0, 500)}`);
          throw error; // Re-lancer pour √™tre captur√© par le catch externe
        }
        
        const upsertDuration = Date.now() - upsertStartTime;
        
        if (savedSale && savedSale.id) {
          syncLogger.info(`      ‚úÖ [SQL] Facture ${invoiceNumber} ${isNew ? 'CR√â√âE' : 'MISE √Ä JOUR'} dans SQLite en ${upsertDuration}ms`);
          syncLogger.info(`         üìç Sale ID: ${savedSale.id}, UUID: ${savedSale.uuid || 'N/A'}`);
          syncLogger.info(`         üìä Items stock√©s: ${saleData.items.length}, Total FC: ${totalFC.toLocaleString()}`);
          syncLogger.info(`         üíæ Stockage confirm√©: Table "sales" ‚Üí ID=${savedSale.id}, Table "sale_items" ‚Üí ${saleData.items.length} ligne(s)`);
          
          // V√©rification post-stockage IMM√âDIATE pour confirmer
          try {
            const verifySale = salesRepo.findByInvoice(invoiceNumber);
            if (verifySale && verifySale.id === savedSale.id) {
              const itemsCount = verifySale.items ? verifySale.items.length : 0;
              syncLogger.info(`      ‚úÖ [SQL] V√âRIFICATION IMM√âDIATE: Facture ${invoiceNumber} trouv√©e dans SQLite`);
              syncLogger.info(`         üìç ID: ${verifySale.id}, UUID: ${verifySale.uuid || 'N/A'}`);
              syncLogger.info(`         üìä Items: ${itemsCount} item(s) trouv√©(s) dans sale_items`);
              syncLogger.info(`         üí∞ Total FC: ${verifySale.total_fc || 0}`);
              syncLogger.info(`      ‚úÖ [SQL] ‚úÖ CONFIRM√â: Les donn√©es sont bien √©crites dans la base SQLite locale`);
              
              // V√©rification suppl√©mentaire: compter les items dans sale_items
              try {
                const { getDb } = await import('../../db/sqlite.js');
                const db = getDb();
                const itemsInDb = db.prepare('SELECT COUNT(*) as count FROM sale_items WHERE sale_id = ?').get(savedSale.id);
                syncLogger.info(`      ‚úÖ [SQL] V√©rification table sale_items: ${itemsInDb.count} item(s) li√©(s) √† cette facture`);
                if (itemsInDb.count !== saleData.items.length) {
                  syncLogger.warn(`      ‚ö†Ô∏è  [SQL] ATTENTION: Nombre d'items diff√©rent (attendu: ${saleData.items.length}, trouv√©: ${itemsInDb.count})`);
                }
              } catch (itemsCheckError) {
                syncLogger.warn(`      ‚ö†Ô∏è  [SQL] Erreur lors de la v√©rification des items: ${itemsCheckError.message}`);
              }
            } else {
              syncLogger.error(`      ‚ùå [SQL] V√âRIFICATION √âCHOU√âE: Facture ${invoiceNumber} non trouv√©e apr√®s stockage`);
              syncLogger.error(`         üìã Recherche effectu√©e avec invoice_number="${invoiceNumber}"`);
              syncLogger.error(`         üîç R√©sultat: ${verifySale ? 'trouv√©e mais ID diff√©rent' : 'non trouv√©e'}`);
            }
          } catch (verifyError) {
            syncLogger.error(`      ‚ùå [SQL] Erreur lors de la v√©rification post-stockage: ${verifyError.message}`);
            syncLogger.error(`         Stack: ${verifyError.stack?.substring(0, 300)}`);
          }
        } else {
          syncLogger.error(`      ‚ùå [SQL] √âCHEC: Impossible de stocker la facture ${invoiceNumber} dans SQLite`);
          syncLogger.error(`         üìã R√©sultat upsert: ${savedSale ? JSON.stringify(savedSale).substring(0, 200) : 'null/undefined'}`);
          if (!savedSale || !savedSale.id) {
            syncLogger.error(`         üí° Diagnostic: salesRepo.upsert() n'a pas retourn√© de vente avec un ID`);
            syncLogger.error(`         üí° V√©rifier que la transaction SQLite s'est bien ex√©cut√©e`);
          }
        }
        
        if (isNew) {
          insertedCount++;
        } else {
          updatedCount++;
        }
      } catch (error) {
        errorCount++;
        syncLogger.error(`   ‚ùå [SALES] Erreur lors du stockage de la facture ${invoiceNumber}:`, error.message || error);
        if (error.stack) {
          syncLogger.error(`      Stack: ${error.stack.substring(0, 300)}...`);
        }
      }
    }
    
    const duration = Date.now() - startTime;
    const totalProcessed = insertedCount + updatedCount;
    
    // V√©rification finale dans SQLite pour confirmer le stockage
    let totalSalesInDb = 0;
    try {
      // Utiliser salesRepo pour v√©rifier le nombre de ventes dans SQLite
      const allSales = salesRepo.findAll({}); // R√©cup√©rer toutes les ventes
      totalSalesInDb = allSales.filter(s => s.origin === 'SHEETS').length;
      syncLogger.info(`   üîç [SQL] V√âRIFICATION SQLite: ${totalSalesInDb} facture(s) avec origin='SHEETS' trouv√©e(s) dans la table "sales"`);
      syncLogger.info(`   ‚úÖ [SQL] Les ventes sont bien stock√©es dans la base de donn√©es SQLite locale`);
    } catch (verifyError) {
      syncLogger.warn(`   ‚ö†Ô∏è  [SQL] Erreur lors de la v√©rification SQLite: ${verifyError.message}`);
    }
    
    syncLogger.info(`üí∞ [SALES] ==========================================`);
    syncLogger.info(`üí∞ [SALES] R√âSULTAT FINAL DE LA SYNCHRONISATION:`);
    syncLogger.info(`üí∞ [SALES] ==========================================`);
    syncLogger.info(`   üì• SOURCE: Google Sheets (feuille "Ventes")`);
    syncLogger.info(`   üì¶ R√âCEPTION: ${data.length} ligne(s) t√©l√©charg√©e(s) depuis Sheets`);
    syncLogger.info(`   üîÑ GROUPEMENT: ${uniqueInvoicesCount} facture(s) unique(s) d√©tect√©e(s)`);
    syncLogger.info(`   üíæ STOCKAGE SQLite:`);
    syncLogger.info(`      ‚úÖ ${insertedCount} facture(s) CR√â√âE(S) (INSERT INTO sales)`);
    syncLogger.info(`      ‚úÖ ${updatedCount} facture(s) MIS(E) √Ä JOUR (UPDATE sales)`);
    if (skippedCount > 0) {
      syncLogger.info(`      ‚è≠Ô∏è  ${skippedCount} facture(s) IGNOR√âE(S) (d√©j√† synchronis√©es et identiques)`);
      syncLogger.info(`         üí° Ces ventes existent d√©j√† dans SQLite avec les m√™mes donn√©es ‚Üí Pas de ret√©l√©chargement n√©cessaire`);
    }
    if (errorCount > 0) {
      syncLogger.warn(`      ‚ùå ${errorCount} facture(s) EN ERREUR (non stock√©es)`);
    }
    syncLogger.info(`   üìä TOTAL TRAIT√â: ${totalProcessed} facture(s) trait√©e(s) (${insertedCount} cr√©√©e(s) + ${updatedCount} mise(s) √† jour) dans SQLite`);
    syncLogger.info(`   ‚úÖ V√âRIFICATION SQLite: ${totalSalesInDb} facture(s) avec origin='SHEETS' dans la base de donn√©es`);
    
    // V√©rification des items dans sale_items
    let totalItemsInDb = 0;
    try {
      const { getDb } = await import('../../db/sqlite.js');
      const db = getDb();
      const itemsCountResult = db.prepare('SELECT COUNT(*) as count FROM sale_items').get();
      totalItemsInDb = itemsCountResult?.count || 0;
      syncLogger.info(`   ‚úÖ V√âRIFICATION SQLite: ${totalItemsInDb} item(s) dans la table "sale_items"`);
    } catch (itemsError) {
      syncLogger.warn(`   ‚ö†Ô∏è  Erreur lors de la v√©rification des items: ${itemsError.message}`);
    }
    
    // LOG FINAL TR√àS VISIBLE POUR CONFIRMER LE STOCKAGE
    syncLogger.info(`   üéâ [SALES] ==========================================`);
    syncLogger.info(`   üéâ [SALES] ‚úÖ CONFIRMATION FINALE DU STOCKAGE:`);
    syncLogger.info(`   üéâ [SALES] ==========================================`);
    
    // Calculer les nouvelles ventes ajout√©es
    const newSalesAdded = totalSalesInDb - salesCountBefore;
    const newItemsAdded = totalItemsInDb - itemsCountBefore;
    
    syncLogger.info(`   üìä [SALES] COMPARAISON AVANT/APR√àS:`);
    syncLogger.info(`      üì• AVANT: ${salesCountBefore} vente(s), ${itemsCountBefore} item(s)`);
    syncLogger.info(`      üì• APR√àS: ${totalSalesInDb} vente(s), ${totalItemsInDb} item(s)`);
    syncLogger.info(`      ‚ûï AJOUT√â: ${newSalesAdded} nouvelle(s) vente(s), ${newItemsAdded} nouvel(aux) item(s)`);
    
    if (totalSalesInDb > 0 && totalItemsInDb > 0) {
      syncLogger.info(`   ‚úÖ [SALES] ‚úÖ LES VENTES SONT BIEN STOCK√âES DANS SQLITE!`);
      syncLogger.info(`   ‚úÖ [SALES] ‚úÖ ${totalSalesInDb} vente(s) dans la table "sales" (origin='SHEETS')`);
      syncLogger.info(`   ‚úÖ [SALES] ‚úÖ ${totalItemsInDb} item(s) dans la table "sale_items"`);
      
      if (newSalesAdded > 0 || newItemsAdded > 0) {
        syncLogger.info(`   üéâ [SALES] ‚úÖ ${newSalesAdded} nouvelle(s) vente(s) ajout√©e(s) avec succ√®s!`);
        syncLogger.info(`   üéâ [SALES] ‚úÖ ${newItemsAdded} nouvel(aux) item(s) ajout√©(s) avec succ√®s!`);
      } else if (insertedCount > 0 || updatedCount > 0) {
        syncLogger.warn(`   ‚ö†Ô∏è  [SALES] ATTENTION: Des ventes ont √©t√© trait√©es (${insertedCount} cr√©√©e(s), ${updatedCount} mise(s) √† jour) mais le nombre total n'a pas chang√©`);
        syncLogger.warn(`   üí° [SALES] Raison possible: Les ventes existaient d√©j√† et ont √©t√© mises √† jour`);
      }
      
      syncLogger.info(`   ‚úÖ [SALES] ‚úÖ Les ventes sont disponibles dans la page "Historique des ventes"`);
      syncLogger.info(`   ‚úÖ [SALES] ‚úÖ URL: /sales/history (Menu ‚Üí Historique)`);
    } else {
      syncLogger.error(`   ‚ùå [SALES] ERREUR CRITIQUE: Aucune vente trouv√©e dans SQLite apr√®s traitement!`);
      syncLogger.error(`   üìä [SALES] Statistiques de traitement:`);
      syncLogger.error(`      ‚úÖ Trait√©es: ${insertedCount} cr√©√©e(s), ${updatedCount} mise(s) √† jour, ${skippedCount} ignor√©e(s)`);
      syncLogger.error(`      ‚ùå Erreurs: ${errorCount}`);
      syncLogger.error(`   üí° [SALES] Diagnostic:`);
      syncLogger.error(`      1. V√©rifier que salesRepo.upsert() fonctionne correctement`);
      syncLogger.error(`      2. V√©rifier que la transaction SQLite s'ex√©cute sans erreur`);
      syncLogger.error(`      3. V√©rifier les logs d'erreur ci-dessus pour chaque facture`);
      syncLogger.error(`      4. V√©rifier que la base de donn√©es SQLite est accessible`);
      
      // Tentative de diagnostic suppl√©mentaire
      try {
        const { getDb } = await import('../../db/sqlite.js');
        const db = getDb();
        const allSales = db.prepare('SELECT COUNT(*) as count FROM sales').get();
        const allItems = db.prepare('SELECT COUNT(*) as count FROM sale_items').get();
        syncLogger.error(`   üîç [SALES] Diagnostic SQLite:`);
        syncLogger.error(`      üìä Total ventes (toutes origines): ${allSales.count}`);
        syncLogger.error(`      üìä Total items (toutes origines): ${allItems.count}`);
        if (allSales.count > 0) {
          const sampleSale = db.prepare('SELECT invoice_number, origin FROM sales LIMIT 1').get();
          syncLogger.error(`      üìã Exemple de vente: ${sampleSale?.invoice_number || 'N/A'}, origin=${sampleSale?.origin || 'N/A'}`);
        }
      } catch (diagError) {
        syncLogger.error(`   ‚ùå [SALES] Erreur lors du diagnostic: ${diagError.message}`);
      }
    }
    syncLogger.info(`   üéâ [SALES] ==========================================`);
    
    syncLogger.info(`   ‚è±Ô∏è  Dur√©e totale: ${duration}ms`);
    syncLogger.info(`üí∞ [SALES] ==========================================`);
    
    if (totalProcessed > 0) {
      syncLogger.info(`   üéâ [SALES] ‚úÖ SYNCHRONISATION R√âUSSIE!`);
      syncLogger.info(`   üì± [SALES] Les ventes sont maintenant disponibles dans l'application:`);
      syncLogger.info(`      üìÑ Page "Historique des ventes" (Menu ‚Üí Historique)`);
      syncLogger.info(`      üîó URL: /sales/history`);
      syncLogger.info(`      üí° Note: Ajustez les dates (Du/Au) pour voir toutes les ventes synchronis√©es`);
    }
    
    if (skippedCount > 0 && totalProcessed === 0) {
      syncLogger.info(`   ‚ÑπÔ∏è  [SALES] Toutes les ventes t√©l√©charg√©es √©taient d√©j√† synchronis√©es ‚Üí Aucune modification n√©cessaire`);
      syncLogger.info(`   ‚úÖ [SALES] Les ventes sont d√©j√† pr√©sentes dans SQLite et visibles dans l'interface`);
    }
    
    // Log final de confirmation
    syncLogger.info(`   ‚úÖ [SALES] SYNCHRONISATION TERMIN√âE: Les ventes de Sheets sont bien synchronis√©es vers SQLite local`);
    syncLogger.info(`   üìç [SALES] LOCALISATION: Base de donn√©es SQLite ‚Üí Tables "sales" et "sale_items"`);
    
    return { 
      inserted: insertedCount, 
      updated: updatedCount, 
      skipped: skippedCount,
      errorCount: errorCount
    };
  }
  
  /**
   * V√©rifie que les ventes sont bien synchronis√©es depuis Sheets vers SQLite
   * Compare la structure et le contenu des tables
   */
  async verifySalesSync() {
    try {
      syncLogger.info(`üîç [VERIFY-SALES] ==========================================`);
      syncLogger.info(`üîç [VERIFY-SALES] V√âRIFICATION DE LA SYNCHRONISATION DES VENTES`);
      syncLogger.info(`üîç [VERIFY-SALES] ==========================================`);
      
      const { getDb } = await import('../../db/sqlite.js');
      const db = getDb();
      
      // 1. Compter les ventes dans SQLite
      const allSalesInDb = salesRepo.findAll({});
      const salesFromSheets = allSalesInDb.filter(s => s.origin === 'SHEETS');
      const totalSalesInDb = allSalesInDb.length;
      const salesFromSheetsCount = salesFromSheets.length;
      
      syncLogger.info(`   üìä [VERIFY-SALES] SQLite (table 'sales'):`);
      syncLogger.info(`      ‚úÖ Total ventes: ${totalSalesInDb}`);
      syncLogger.info(`      ‚úÖ Ventes depuis Sheets (origin='SHEETS'): ${salesFromSheetsCount}`);
      
      // 2. Compter les items dans SQLite
      const itemsCountResult = db.prepare('SELECT COUNT(*) as count FROM sale_items').get();
      const totalItemsInDb = itemsCountResult?.count || 0;
      
      syncLogger.info(`   üìä [VERIFY-SALES] SQLite (table 'sale_items'):`);
      syncLogger.info(`      ‚úÖ Total items: ${totalItemsInDb}`);
      
      // 4. Afficher quelques exemples de ventes stock√©es
      if (salesFromSheets.length > 0) {
        syncLogger.info(`   üìã [VERIFY-SALES] Exemples de ventes stock√©es (5 derni√®res):`);
        const recentSales = salesFromSheets
          .sort((a, b) => new Date(b.sold_at || 0) - new Date(a.sold_at || 0))
          .slice(0, 5);
        
        for (const sale of recentSales) {
          const itemsCount = sale.items ? sale.items.length : 0;
          syncLogger.info(`      üìÑ Facture: ${sale.invoice_number || 'N/A'}`);
          syncLogger.info(`         Client: ${sale.client_name || 'N/A'}, Total: ${(sale.total_fc || 0).toLocaleString()} FC`);
          syncLogger.info(`         Date: ${sale.sold_at || 'N/A'}, Items: ${itemsCount}, UUID: ${sale.uuid || 'N/A'}`);
        }
      } else {
        syncLogger.warn(`      ‚ö†Ô∏è  Aucune vente depuis Sheets trouv√©e dans SQLite`);
        syncLogger.warn(`      üí° V√©rifier que getSalesPage() dans Code.gs retourne des donn√©es`);
      }
      
      // 5. R√©cup√©rer un √©chantillon depuis Sheets pour comparer
      syncLogger.info(`   üì• [VERIFY-SALES] V√©rification de la disponibilit√© des donn√©es dans Sheets...`);
      
      try {
        // R√©cup√©rer quelques lignes depuis Sheets (premi√®re page seulement pour v√©rification)
        const sampleResult = await sheetsClient.pullAllPaged('sales', new Date(0).toISOString(), {
          full: true,
          startCursor: 2, // Commencer √† la ligne 2 (apr√®s header)
          maxRetries: 2,
          timeout: 15000,
          limit: 50 // R√©cup√©rer les 50 premi√®res lignes pour v√©rification
        });
        
        if (sampleResult.success && sampleResult.data && sampleResult.data.length > 0) {
          const sampleLinesFromSheets = sampleResult.data.length;
          syncLogger.info(`   üì• [VERIFY-SALES] Google Sheets (feuille "Ventes"):`);
          syncLogger.info(`      ‚úÖ √âchantillon r√©cup√©r√©: ${sampleLinesFromSheets} ligne(s) (sur probablement beaucoup plus)`);
          syncLogger.info(`      ‚úÖ Les donn√©es sont disponibles dans Google Sheets`);
          
          // V√©rifier la structure des donn√©es
          const firstItem = sampleResult.data[0];
          if (firstItem) {
            syncLogger.info(`   üìã [VERIFY-SALES] Structure des donn√©es Sheets v√©rifi√©e:`);
            syncLogger.info(`      ‚úÖ invoice_number: ${firstItem.invoice_number ? '‚úì Pr√©sent' : '‚úó Manquant'}`);
            syncLogger.info(`      ‚úÖ sold_at: ${firstItem.sold_at ? '‚úì Pr√©sent' : '‚úó Manquant'}`);
            syncLogger.info(`      ‚úÖ product_code: ${firstItem.product_code ? '‚úì Pr√©sent' : '‚úó Manquant'}`);
            syncLogger.info(`      ‚úÖ client_name: ${firstItem.client_name ? '‚úì Pr√©sent' : '‚úó Manquant'}`);
            syncLogger.info(`      ‚úÖ qty: ${firstItem.qty !== undefined ? '‚úì Pr√©sent' : '‚úó Manquant'}`);
            syncLogger.info(`      ‚úÖ unit_price_fc: ${firstItem.unit_price_fc !== undefined ? '‚úì Pr√©sent' : '‚úó Manquant'}`);
            syncLogger.info(`      ‚úÖ seller_name: ${firstItem.seller_name ? '‚úì Pr√©sent' : '‚úó Manquant'}`);
            syncLogger.info(`      ‚úÖ unit_level: ${firstItem.unit_level ? '‚úì Pr√©sent' : '‚úó Manquant'}`);
            syncLogger.info(`      ‚úÖ client_phone: ${firstItem.client_phone !== undefined ? '‚úì Pr√©sent' : '‚úó Manquant'}`);
            syncLogger.info(`      ‚úÖ uuid: ${firstItem.uuid ? '‚úì Pr√©sent' : '‚úó Manquant'}`);
          }
          
          // Grouper par facture pour compter les factures uniques
          const invoicesInSample = new Set();
          sampleResult.data.forEach(item => {
            if (item.invoice_number) {
              invoicesInSample.add(item.invoice_number);
            }
          });
          
          syncLogger.info(`   üìä [VERIFY-SALES] √âchantillon Sheets: ${invoicesInSample.size} facture(s) unique(s) dans les ${sampleLinesFromSheets} ligne(s)`);
          
          // V√©rifier si ces factures existent dans SQLite
          let foundInDb = 0;
          let missingInDb = 0;
          const missingInvoices = [];
          
          for (const invoiceNumber of invoicesInSample) {
            const saleInDb = salesRepo.findByInvoice(invoiceNumber);
            if (saleInDb) {
              foundInDb++;
            } else {
              missingInDb++;
              if (missingInDb <= 10) { // Logger les 10 premiers manquants
                missingInvoices.push(invoiceNumber);
              }
            }
          }
          
          syncLogger.info(`   ‚úÖ [VERIFY-SALES] Factures de l'√©chantillon v√©rifi√©es dans SQLite:`);
          syncLogger.info(`      ‚úÖ Trouv√©es: ${foundInDb}/${invoicesInSample.size}`);
          if (missingInDb > 0) {
            syncLogger.warn(`      ‚ö†Ô∏è  Manquantes: ${missingInDb}/${invoicesInSample.size}`);
            if (missingInvoices.length > 0) {
              syncLogger.warn(`      ‚ö†Ô∏è  Exemples de factures manquantes: ${missingInvoices.slice(0, 5).join(', ')}${missingInvoices.length > 5 ? '...' : ''}`);
            }
            syncLogger.info(`      üí° [VERIFY-SALES] Ces factures seront synchronis√©es au prochain cycle (dans 10s)`);
          }
        } else {
          syncLogger.warn(`   ‚ö†Ô∏è  [VERIFY-SALES] Impossible de r√©cup√©rer l'√©chantillon depuis Sheets: ${sampleResult.error || 'Aucune donn√©e'}`);
        }
      } catch (verifyError) {
        syncLogger.warn(`   ‚ö†Ô∏è  [VERIFY-SALES] Erreur lors de la r√©cup√©ration de l'√©chantillon depuis Sheets: ${verifyError.message}`);
      }
      
      // 6. V√©rification de l'int√©grit√© des donn√©es
      syncLogger.info(`   üîç [VERIFY-SALES] V√©rification de l'int√©grit√© des donn√©es...`);
      
      // V√©rifier les ventes sans items
      const salesWithoutItems = db.prepare(`
        SELECT s.id, s.invoice_number, s.origin
        FROM sales s
        LEFT JOIN sale_items si ON s.id = si.sale_id
        WHERE si.id IS NULL AND s.origin = 'SHEETS'
        LIMIT 10
      `).all();
      
      if (salesWithoutItems.length > 0) {
        syncLogger.warn(`      ‚ö†Ô∏è  ${salesWithoutItems.length} vente(s) synchronis√©e(s) sans items d√©tect√©e(s) (exemples):`);
        for (const sale of salesWithoutItems.slice(0, 5)) {
          syncLogger.warn(`         - Facture ${sale.invoice_number} (ID: ${sale.id})`);
        }
      } else {
        syncLogger.info(`      ‚úÖ Toutes les ventes synchronis√©es ont des items associ√©s`);
      }
      
      // V√©rifier les items sans vente (ne devrait jamais arriver)
      const itemsWithoutSale = db.prepare(`
        SELECT COUNT(*) as count
        FROM sale_items si
        LEFT JOIN sales s ON si.sale_id = s.id
        WHERE s.id IS NULL
      `).get();
      
      if (itemsWithoutSale.count > 0) {
        syncLogger.error(`      ‚ùå ${itemsWithoutSale.count} item(s) orphelin(s) (sans vente associ√©e) - CORRECTION N√âCESSAIRE`);
      } else {
        syncLogger.info(`      ‚úÖ Tous les items sont associ√©s √† une vente`);
      }
      
      // 7. Statistiques d√©taill√©es par p√©riode
      const last7Days = new Date();
      last7Days.setDate(last7Days.getDate() - 7);
      const salesLast7Days = db.prepare(`
        SELECT COUNT(*) as count, SUM(total_fc) as total_fc
        FROM sales
        WHERE origin = 'SHEETS' AND sold_at >= ?
      `).get(last7Days.toISOString());
      
      syncLogger.info(`   üìä [VERIFY-SALES] Statistiques des 7 derniers jours:`);
      syncLogger.info(`      ‚úÖ Ventes synchronis√©es: ${salesLast7Days.count || 0}`);
      syncLogger.info(`      ‚úÖ Total FC: ${(salesLast7Days.total_fc || 0).toLocaleString()}`);
      
      // 8. V√©rification finale et r√©sum√©
      syncLogger.info(`   ‚úÖ [VERIFY-SALES] R√âSUM√â DE LA V√âRIFICATION:`);
      syncLogger.info(`      üìä Ventes dans SQLite: ${totalSalesInDb} total (${salesFromSheetsCount} depuis Sheets)`);
      syncLogger.info(`      üì¶ Items dans SQLite: ${totalItemsInDb}`);
      syncLogger.info(`      ‚úÖ Int√©grit√©: ${salesWithoutItems.length === 0 ? 'OK' : 'ATTENTION - Ventes sans items d√©tect√©es'}`);
      
      if (salesFromSheetsCount > 0 && totalItemsInDb > 0) {
        syncLogger.info(`      üéâ [VERIFY-SALES] ‚úÖ CONFIRM√â: Les ventes sont bien t√©l√©charg√©es et stock√©es dans SQLite!`);
        syncLogger.info(`      üìç [VERIFY-SALES] Tables: "sales" (${totalSalesInDb} ventes) + "sale_items" (${totalItemsInDb} items)`);
        syncLogger.info(`      üìÑ [VERIFY-SALES] Les ventes sont disponibles dans la page "Historique des ventes"`);
        syncLogger.info(`      üîó [VERIFY-SALES] URL: /sales/history (Menu ‚Üí Historique)`);
      } else if (salesFromSheetsCount === 0) {
        syncLogger.warn(`      ‚ö†Ô∏è  [VERIFY-SALES] Aucune vente avec origin='SHEETS' trouv√©e dans SQLite`);
        syncLogger.info(`      üí° [VERIFY-SALES] La synchronisation continue... Les ventes seront t√©l√©charg√©es progressivement`);
        syncLogger.info(`      üí° [VERIFY-SALES] V√©rifier les logs pr√©c√©dents pour voir si des ventes sont en cours de t√©l√©chargement`);
      } else {
        syncLogger.warn(`      ‚ö†Ô∏è  [VERIFY-SALES] Items manquants: ${salesFromSheetsCount} ventes mais seulement ${totalItemsInDb} items`);
        syncLogger.warn(`      üí° [VERIFY-SALES] V√©rifier que les items sont bien cr√©√©s lors de l'upsert`);
      }
      
      syncLogger.info(`üîç [VERIFY-SALES] ==========================================`);
      
    } catch (error) {
      syncLogger.error(`   ‚ùå [VERIFY-SALES] Erreur lors de la v√©rification: ${error.message}`);
      if (error.stack) {
        syncLogger.error(`      Stack: ${error.stack.substring(0, 300)}...`);
      }
    }
  }

  /**
   * Applique les mises √† jour de dettes
   * @returns {Promise<{inserted: number, updated: number, skipped: number}>} Stats d'upsert
   */
  async applyDebtsUpdates(data) {
    const startTime = Date.now();
    syncLogger.info(`üí≥ [DEBTS] D√©but application de ${data.length} dette(s) dans SQLite...`);
    syncLogger.info(`   üíæ [SQL] Table: debts, Op√©ration: INSERT/UPDATE`);
    
    if (!data || data.length === 0) {
      syncLogger.warn(`‚ö†Ô∏è  [DEBTS] Aucune donn√©e dette √† appliquer dans SQL`);
      return { inserted: 0, updated: 0, skipped: 0 };
    }
    
    syncLogger.info(`   üìä [SQL] Type de donn√©es: ${Array.isArray(data) ? 'array' : typeof data}, ${data.length} ligne(s) √† traiter`);
    if (data.length > 0) {
      syncLogger.info(`   üîç [SQL] Premier item: ${JSON.stringify(data[0]).substring(0, 300)}...`);
    }
    
    let insertedCount = 0;
    let updatedCount = 0;
    let skippedCount = 0;
    let errorCount = 0;
    
    for (let i = 0; i < data.length; i++) {
      const item = data[i];
      const itemStartTime = Date.now();
      
      try {
        if (!item.invoice_number) {
          syncLogger.warn(`   ‚ö†Ô∏è  [${i+1}/${data.length}] Dette ignor√©e: pas de num√©ro de facture`);
          skippedCount++;
          continue;
        }
        
        // V√©rifier si la dette existe d√©j√†
        const existing = debtsRepo.findByInvoice(item.invoice_number);
        const isNew = !existing;
        
        // Cr√©er ou mettre √† jour la dette
        syncLogger.info(`   üí≥ [${i+1}/${data.length}] ${isNew ? 'INSERT' : 'UPDATE'} SQL pour dette ${item.invoice_number}`);
        syncLogger.info(`      üìã [SQL] Client: ${item.client_name || 'N/A'}`);
        syncLogger.info(`      üìã [SQL] Total: ${item.total_fc || 0} FC`);
        syncLogger.info(`      üìã [SQL] Pay√©: ${item.paid_fc || 0} FC`);
        syncLogger.info(`      üìã [SQL] Reste: ${item.remaining_fc !== undefined ? item.remaining_fc : (item.total_fc || 0) - (item.paid_fc || 0)} FC`);
        syncLogger.info(`      üìã [SQL] Status: ${item.status || 'open'}`);
        
        // G√©n√©rer un UUID si non fourni
        const debtUuid = item.uuid || null;
        
        const debtData = {
          uuid: debtUuid,
          invoice_number: item.invoice_number,
          client_name: item.client_name || '',
          client_phone: item.client_phone || null,
          product_description: item.product_description || null,
          total_fc: item.total_fc || 0,
          paid_fc: item.paid_fc || 0,
          remaining_fc: item.remaining_fc !== undefined ? item.remaining_fc : (item.total_fc || 0) - (item.paid_fc || 0),
          total_usd: item.total_usd || 0,
          debt_fc_in_usd: item.debt_fc_in_usd || null,
          note: item.note || null,
          status: item.status || 'open',
          created_at: item.created_at || new Date().toISOString()
        };
        
        syncLogger.debug(`      üìã Donn√©es compl√®tes: ${JSON.stringify(debtData).substring(0, 400)}...`);
        
        const upsertResult = debtsRepo.upsert(debtData);
        
        const itemDuration = Date.now() - itemStartTime;
        if (isNew) {
          insertedCount++;
          syncLogger.info(`      ‚úÖ [SQL] INSERT r√©ussie: Dette "${item.invoice_number}" INS√âR√âE dans SQL en ${itemDuration}ms`);
          syncLogger.info(`      üìä [SQL] ID SQLite: ${upsertResult?.id || 'N/A'}, UUID: ${upsertResult?.uuid || 'N/A'}`);
          syncLogger.info(`      ‚úÖ [SQL] Dette maintenant DISPONIBLE dans la page Dettes`);
        } else {
          updatedCount++;
          syncLogger.info(`      ‚úÖ [SQL] UPDATE r√©ussie: Dette "${item.invoice_number}" MIS √Ä JOUR dans SQL en ${itemDuration}ms`);
          syncLogger.info(`      üìä [SQL] ID SQLite: ${upsertResult?.id || 'N/A'}, UUID: ${upsertResult?.uuid || 'N/A'}`);
          syncLogger.info(`      ‚úÖ [SQL] Dette maintenant √Ä JOUR dans la page Dettes`);
        }
      } catch (error) {
        errorCount++;
        const errorDuration = Date.now() - itemStartTime;
        syncLogger.error(`      ‚ùå [${i+1}/${data.length}] Erreur apr√®s ${errorDuration}ms`);
        syncLogger.error(`         Invoice: ${item.invoice_number || 'N/A'}`);
        syncLogger.error(`         Message: ${error.message}`);
        syncLogger.error(`         Code: ${error.code || 'N/A'}`);
        
        if (error.message && (error.message.includes('uuid') || error.message.includes('client_phone'))) {
          syncLogger.error(`         ‚ö†Ô∏è  Probl√®me de sch√©ma d√©tect√©: ${error.message}`);
          syncLogger.error(`         üí° La migration devrait corriger cela au prochain red√©marrage`);
        }
        
        syncLogger.error(`         Stack: ${error.stack?.substring(0, 400)}...`);
      }
    }
    
    const totalDuration = Date.now() - startTime;
    syncLogger.info(`‚úÖ [DEBTS] Application SQL termin√©e en ${totalDuration}ms`);
    syncLogger.info(`   üìä [SQL] R√©sum√© SQL:`);
    syncLogger.info(`      ‚úÖ ${insertedCount} dette(s) INS√âR√âE(S) (INSERT INTO debts)`);
    syncLogger.info(`      ‚úÖ ${updatedCount} dette(s) MIS(E) √Ä JOUR (UPDATE debts)`);
    syncLogger.info(`      ‚è≠Ô∏è  ${skippedCount} dette(s) IGNOR√âE(S) (d√©j√† existantes)`);
    syncLogger.info(`      ‚ùå ${errorCount} dette(s) EN ERREUR`);
    syncLogger.info(`   ‚è±Ô∏è  [SQL] Temps moyen par dette: ${(insertedCount + updatedCount) > 0 ? Math.round(totalDuration / (insertedCount + updatedCount)) : 0}ms`);
    
    if (insertedCount + updatedCount > 0) {
      syncLogger.info(`   üéâ [SQL] ${insertedCount + updatedCount} dette(s) maintenant STOCK√âE(S) dans SQLite et DISPONIBLE(S) dans la page Dettes!`);
      syncLogger.info(`   üìä [SQL] V√©rification: SELECT COUNT(*) FROM debts; devrait retourner au moins ${insertedCount + updatedCount} ligne(s)`);
    }
    
    if (errorCount > 0) {
      syncLogger.warn(`   ‚ö†Ô∏è  [SQL] ${errorCount} dette(s) n'ont pas pu √™tre synchronis√©e(s) dans SQL`);
      syncLogger.warn(`   üí° [SQL] V√©rifier les logs ci-dessus pour plus de d√©tails`);
    }
    
    return { inserted: insertedCount, updated: updatedCount, skipped: skippedCount };
  }

  /**
   * Applique les mises √† jour de taux
   */
  async applyRatesUpdates(data) {
    syncLogger.info(`üí± Application de ${data.length} taux de change...`);
    
    // Prendre le taux le plus r√©cent
    if (data.length > 0) {
      const latestRate = data[data.length - 1]; // D√©j√† tri√© par date
      try {
        syncLogger.info(`   üí± Mise √† jour taux de change: ${latestRate.rate_fc_per_usd} FC/USD`);
        ratesRepo.updateCurrent(latestRate.rate_fc_per_usd, null);
        syncLogger.info(`‚úÖ Taux de change mis √† jour avec succ√®s`);
      } catch (error) {
        syncLogger.error(`   ‚ùå Erreur mise √† jour taux:`, error.message || error);
      }
    } else {
      syncLogger.info(`   ‚ÑπÔ∏è  Aucun taux de change √† appliquer`);
    }
  }

  /**
   * Applique les mises √† jour d'utilisateurs (bas√© sur UUID)
   */
  async applyUsersUpdates(data) {
    if (!data || data.length === 0) {
      syncLogger.warn('‚ö†Ô∏è  [USERS] Aucune donn√©e utilisateur √† appliquer');
      return;
    }

    syncLogger.info(`üë• [USERS] ==========================================`);
    syncLogger.info(`üë• [USERS] D√©but application de ${data.length} utilisateur(s)...`);
    syncLogger.info(`üë• [USERS] ==========================================`);
    
    // Construire index local pour matching rapide
    const localUsers = usersRepo.findAll();
    const byUuid = new Map();
    const byUsername = new Map();
    
    for (const user of localUsers) {
      if (user.uuid) {
        byUuid.set(user.uuid.trim(), user);
      }
      if (user.username) {
        const normalized = usersRepo.normalizeUsername(user.username);
        byUsername.set(normalized, user);
      }
    }
    
    syncLogger.info(`   üìä [USERS] Index local: ${byUuid.size} avec UUID, ${byUsername.size} par username`);
    
    // Log du premier utilisateur pour voir la structure
    if (data.length > 0) {
      syncLogger.info(`üë• [USERS] Exemple de donn√©es re√ßues (premier utilisateur):`);
      syncLogger.info(`   üìã UUID: ${data[0].uuid || data[0]._uuid || 'N/A (VIDE)'}`);
      syncLogger.info(`   üìã Username: ${data[0].username || data[0].nom || 'N/A'}`);
      syncLogger.info(`   üìã Phone: ${data[0].phone || data[0].numero || 'N/A'}`);
      syncLogger.info(`   üìã Password: ${data[0].password ? '*** (pr√©sent)' : 'N/A (VIDE)'}`);
      syncLogger.info(`   üìã Is Active: ${data[0].is_active}`);
      syncLogger.info(`   üìã Is Admin: ${data[0].is_admin}`);
    }
    
    let inserted = 0;
    let updated = 0;
    let skipped = 0;
    let repaired = 0; // UUID r√©par√©s

    for (let i = 0; i < data.length; i++) {
      const userData = data[i];
      try {
        const username = userData.username || userData.nom || '';
        if (!username || username.trim() === '') {
          syncLogger.warn(`   ‚ö†Ô∏è  [USERS] Utilisateur #${i + 1} ignor√©: nom vide`);
          skipped++;
          continue;
        }

        syncLogger.info(`   üîç [USERS] Traitement utilisateur #${i + 1}/${data.length}: ${username}`);

        // Extraire UUID (peut √™tre dans uuid ou _uuid)
        const remoteUuid = (userData.uuid || userData._uuid || '').trim();
        
        // A) Si UUID existe ‚Üí UPSERT par UUID
        if (remoteUuid) {
          syncLogger.info(`   üîë [USERS] UUID pr√©sent: ${remoteUuid}`);
          
          const existing = byUuid.get(remoteUuid);
          
          if (existing) {
            syncLogger.info(`   üìù [USERS] Utilisateur existant trouv√© par UUID: ID=${existing.id}, Username=${existing.username}`);
            
            const updateData = {
              phone: userData.phone || userData.numero || existing.phone,
              is_active: userData.is_active !== undefined ? (userData.is_active ? 1 : 0) : existing.is_active,
              is_admin: userData.is_admin !== undefined ? (userData.is_admin ? 1 : 0) : existing.is_admin,
              is_vendeur: userData.is_vendeur !== undefined ? (userData.is_vendeur ? 1 : 0) : (existing.is_vendeur !== undefined ? existing.is_vendeur : 1),
              is_gerant_stock: userData.is_gerant_stock !== undefined ? (userData.is_gerant_stock ? 1 : 0) : (existing.is_gerant_stock || 0),
              can_manage_products: userData.can_manage_products !== undefined ? (userData.can_manage_products ? 1 : 0) : (existing.can_manage_products || 0),
              // PR√âSERVER les URLs existantes : ne pas √©craser si vide depuis Sheets
              device_brand: userData.device_brand || existing.device_brand || '',
              profile_url: userData.profile_url || existing.profile_url || '',
              expo_push_token: userData.expo_push_token || existing.expo_push_token || '',
            };
            
            // CRITIQUE: Toujours mettre √† jour le mot de passe depuis Sheets (m√™me si l'utilisateur existe d√©j√†)
            // Cela garantit que les mots de passe sont synchronis√©s m√™me pour les utilisateurs existants
            syncLogger.debug(`   üîë [USERS] V√©rification mot de passe pour: ${username}, password dans Sheets: ${userData.password ? '*** (pr√©sent)' : 'VIDE'}`);
            
            if (userData.password && userData.password.trim() !== '') {
              updateData.password = userData.password;
              syncLogger.info(`   üîë [USERS] ‚úÖ Mise √† jour du mot de passe depuis Sheets pour: ${username}`);
            } else {
              // Si pas de mot de passe dans Sheets, v√©rifier si l'utilisateur existe sans password_hash
              const db = getDb();
              const userWithHash = db.prepare('SELECT password_hash FROM users WHERE id = ?').get(existing.id);
              syncLogger.debug(`   üîë [USERS] V√©rification password_hash pour: ${username}, has_hash: ${!!userWithHash?.password_hash}`);
              
              if (!userWithHash || !userWithHash.password_hash || userWithHash.password_hash.trim() === '') {
                // Utiliser le mot de passe par d√©faut si l'utilisateur n'a pas de password_hash
                updateData.password = 'changeme123';
                syncLogger.info(`   üîë [USERS] ‚úÖ Pas de mot de passe dans Sheets, utilisation d√©faut pour: ${username} (utilisateur sans password_hash)`);
              } else {
                syncLogger.debug(`   üîë [USERS] ‚è≠Ô∏è  Pas de mot de passe dans Sheets mais utilisateur a d√©j√† un password_hash, conservation pour: ${username}`);
              }
            }
            
            // Log pour debug: v√©rifier que password est bien dans updateData
            if (updateData.password) {
              syncLogger.debug(`   üîë [USERS] ‚úÖ updateData.password est d√©fini pour: ${username}, sera hash√© lors de l'update`);
            } else {
              syncLogger.debug(`   üîë [USERS] ‚ö†Ô∏è  updateData.password est VIDE pour: ${username}`);
            }
            
            syncLogger.debug(`   üîë [USERS] Appel usersRepo.update() pour: ${username}, updateData contient password: ${!!updateData.password}`);
            const updatedUser = await usersRepo.update(existing.id, updateData);
            
            // V√©rifier que le password_hash a bien √©t√© mis √† jour
            const db = getDb();
            const verifyHash = db.prepare('SELECT password_hash FROM users WHERE id = ?').get(existing.id);
            syncLogger.info(`   üîë [USERS] Apr√®s update - password_hash pour ${username}: ${verifyHash?.password_hash ? '‚úÖ HASH√â' : '‚ùå VIDE'}`);
            
            updated++;
            syncLogger.info(`   ‚úÖ [USERS] Utilisateur mis √† jour par UUID: ${username}`);
          } else {
            // UUID existe mais utilisateur non trouv√© par UUID ‚Üí v√©rifier par username
            syncLogger.info(`   üîç [USERS] UUID pr√©sent mais utilisateur non trouv√© par UUID, recherche par username: ${username}`);
            
            const normalized = usersRepo.normalizeUsername(username);
            const existingByUsername = byUsername.get(normalized);
            
            if (existingByUsername) {
              // Utilisateur existe par username mais UUID diff√©rent ‚Üí UPDATE avec r√©paration UUID
              syncLogger.info(`   üîß [USERS] Utilisateur trouv√© par username mais UUID diff√©rent: ID=${existingByUsername.id}, UUID local=${existingByUsername.uuid || 'VIDE'}, UUID Sheets=${remoteUuid}`);
              
              // R√©parer UUID : assigner le UUID de Sheets √† l'utilisateur local
              usersRepo.setUuid(existingByUsername.id, remoteUuid);
              existingByUsername.uuid = remoteUuid;
              byUuid.set(remoteUuid, existingByUsername);
              repaired++;
              
              // Mettre √† jour avec les donn√©es de Sheets
              const updateData = {
                phone: userData.phone || userData.numero || existingByUsername.phone,
                is_active: userData.is_active !== undefined ? (userData.is_active ? 1 : 0) : existingByUsername.is_active,
                is_admin: userData.is_admin !== undefined ? (userData.is_admin ? 1 : 0) : existingByUsername.is_admin,
                is_vendeur: userData.is_vendeur !== undefined ? (userData.is_vendeur ? 1 : 0) : (existingByUsername.is_vendeur !== undefined ? existingByUsername.is_vendeur : 1),
                is_gerant_stock: userData.is_gerant_stock !== undefined ? (userData.is_gerant_stock ? 1 : 0) : (existingByUsername.is_gerant_stock || 0),
                can_manage_products: userData.can_manage_products !== undefined ? (userData.can_manage_products ? 1 : 0) : (existingByUsername.can_manage_products || 0),
                device_brand: userData.device_brand || existingByUsername.device_brand || '',
                profile_url: userData.profile_url || existingByUsername.profile_url || '',
                expo_push_token: userData.expo_push_token || existingByUsername.expo_push_token || '',
              };
              
              // CRITIQUE: Toujours mettre √† jour le mot de passe depuis Sheets
              if (userData.password && userData.password.trim() !== '') {
                updateData.password = userData.password;
                syncLogger.info(`   üîë [USERS] Mise √† jour du mot de passe avec r√©paration UUID pour: ${username}`);
              } else {
                // Si pas de mot de passe dans Sheets mais utilisateur existe sans password_hash, utiliser d√©faut
                const db = getDb();
                const userWithHash = db.prepare('SELECT password_hash FROM users WHERE id = ?').get(existingByUsername.id);
                if (!userWithHash || !userWithHash.password_hash || userWithHash.password_hash.trim() === '') {
                  updateData.password = 'changeme123';
                  syncLogger.info(`   üîë [USERS] Pas de mot de passe dans Sheets, utilisation d√©faut avec r√©paration UUID pour: ${username}`);
                }
              }
              
              await usersRepo.update(existingByUsername.id, updateData);
              updated++;
              syncLogger.info(`   ‚úÖ [USERS] Utilisateur mis √† jour avec r√©paration UUID: ${username} (UUID=${remoteUuid})`);
            } else {
              // Vraiment nouveau : cr√©er
              syncLogger.info(`   ‚ûï [USERS] Nouvel utilisateur avec UUID: ${username}`);
              
              const createData = {
                uuid: remoteUuid,
                username: username.trim(),
                password: userData.password || 'changeme123', // Utiliser le mot de passe depuis Sheets
                phone: userData.phone || userData.numero || '',
                is_active: userData.is_active !== undefined ? (userData.is_active ? 1 : 0) : 1,
                is_admin: userData.is_admin !== undefined ? (userData.is_admin ? 1 : 0) : 0,
                is_vendeur: userData.is_vendeur !== undefined ? (userData.is_vendeur ? 1 : 0) : 1,
                is_gerant_stock: userData.is_gerant_stock !== undefined ? (userData.is_gerant_stock ? 1 : 0) : 0,
                can_manage_products: userData.can_manage_products !== undefined ? (userData.can_manage_products ? 1 : 0) : 0,
                created_at: userData.created_at || new Date().toISOString(),
                device_brand: userData.device_brand || '',
                profile_url: userData.profile_url || '',
                expo_push_token: userData.expo_push_token || '',
              };
              
              try {
                const newUser = await usersRepo.create(createData);
                byUuid.set(remoteUuid, newUser);
                byUsername.set(usersRepo.normalizeUsername(username), newUser);
                inserted++;
                syncLogger.info(`   ‚úÖ [USERS] Nouvel utilisateur cr√©√© avec UUID: ${username} (UUID=${remoteUuid})`);
              } catch (createError) {
                // Fallback : si erreur UNIQUE sur username, essayer update
                if (createError?.code === 'SQLITE_CONSTRAINT_UNIQUE' && String(createError.message || '').includes('users.username')) {
                  syncLogger.warn(`   ‚ö†Ô∏è  [USERS] Erreur UNIQUE username lors de la cr√©ation, tentative UPDATE par username: ${username}`);
                  const existingByUsernameFallback = usersRepo.findByUsername(username.trim());
                  if (existingByUsernameFallback) {
                    // R√©parer UUID et mettre √† jour
                    usersRepo.setUuid(existingByUsernameFallback.id, remoteUuid);
                    const updateDataFallback = {
                      phone: userData.phone || userData.numero || existingByUsernameFallback.phone,
                      is_active: userData.is_active !== undefined ? (userData.is_active ? 1 : 0) : existingByUsernameFallback.is_active,
                      is_admin: userData.is_admin !== undefined ? (userData.is_admin ? 1 : 0) : existingByUsernameFallback.is_admin,
                      is_vendeur: userData.is_vendeur !== undefined ? (userData.is_vendeur ? 1 : 0) : (existingByUsernameFallback.is_vendeur !== undefined ? existingByUsernameFallback.is_vendeur : 1),
                      is_gerant_stock: userData.is_gerant_stock !== undefined ? (userData.is_gerant_stock ? 1 : 0) : (existingByUsernameFallback.is_gerant_stock || 0),
                      can_manage_products: userData.can_manage_products !== undefined ? (userData.can_manage_products ? 1 : 0) : (existingByUsernameFallback.can_manage_products || 0),
                      device_brand: userData.device_brand || existingByUsernameFallback.device_brand || '',
                      profile_url: userData.profile_url || existingByUsernameFallback.profile_url || '',
                      expo_push_token: userData.expo_push_token || existingByUsernameFallback.expo_push_token || '',
                    };
                    
                    // CRITIQUE: Toujours mettre √† jour le mot de passe depuis Sheets
                    if (userData.password && userData.password.trim() !== '') {
                      updateDataFallback.password = userData.password;
                      syncLogger.info(`   üîë [USERS] Mise √† jour du mot de passe (fallback apr√®s erreur UNIQUE) pour: ${username}`);
                    } else {
                      // Si pas de mot de passe dans Sheets mais utilisateur existe sans password_hash, utiliser d√©faut
                      const db = getDb();
                      const userWithHash = db.prepare('SELECT password_hash FROM users WHERE id = ?').get(existingByUsernameFallback.id);
                      if (!userWithHash || !userWithHash.password_hash || userWithHash.password_hash.trim() === '') {
                        updateDataFallback.password = 'changeme123';
                        syncLogger.info(`   üîë [USERS] Pas de mot de passe dans Sheets, utilisation d√©faut (fallback) pour: ${username}`);
                      }
                    }
                    
                    await usersRepo.update(existingByUsernameFallback.id, updateDataFallback);
                    updated++;
                    repaired++;
                    syncLogger.info(`   ‚úÖ [USERS] Utilisateur mis √† jour (fallback apr√®s erreur UNIQUE): ${username} (UUID=${remoteUuid})`);
                  } else {
                    throw createError; // Re-throw si on ne peut pas r√©soudre
                  }
                } else {
                  throw createError; // Re-throw les autres erreurs
                }
              }
            }
          }
          continue;
        }
        
        // B) Si UUID vide ‚Üí chercher par username normalis√©
        syncLogger.info(`   ‚ö†Ô∏è  [USERS] UUID vide, recherche par username: ${username}`);
        
        const normalized = usersRepo.normalizeUsername(username);
        const existing = byUsername.get(normalized);
        
        if (existing) {
          syncLogger.info(`   üîß [USERS] Utilisateur trouv√© par username: ID=${existing.id}, UUID local=${existing.uuid || 'VIDE'}`);
          
          // R√©parer : assigner UUID local si absent, puis mettre √† jour
          let userUuid = existing.uuid;
          if (!userUuid || userUuid.trim() === '') {
            userUuid = generateUUID();
            usersRepo.setUuid(existing.id, userUuid);
            existing.uuid = userUuid;
            byUuid.set(userUuid, existing);
            repaired++;
            syncLogger.info(`   üîß [USERS] UUID r√©par√©: ${userUuid} pour ${username}`);
            
            // Pousser vers Sheets pour backfill UUID - PRO et TOP
            syncRepo.addToOutbox('users', existing.id.toString(), 'upsert', {
              uuid: userUuid,
              username: existing.username,
              phone: existing.phone || '',
              is_admin: existing.is_admin,
              is_active: existing.is_active,
              is_vendeur: existing.is_vendeur !== undefined ? existing.is_vendeur : 1,
              is_gerant_stock: existing.is_gerant_stock || 0,
              can_manage_products: existing.can_manage_products || 0,
            });
          }
          
          // Mettre √† jour (PR√âSERVER les URLs existantes)
          const updateData = {
            phone: userData.phone || userData.numero || existing.phone,
            is_active: userData.is_active !== undefined ? (userData.is_active ? 1 : 0) : existing.is_active,
            is_admin: userData.is_admin !== undefined ? (userData.is_admin ? 1 : 0) : existing.is_admin,
            is_vendeur: userData.is_vendeur !== undefined ? (userData.is_vendeur ? 1 : 0) : (existing.is_vendeur !== undefined ? existing.is_vendeur : 1),
            is_gerant_stock: userData.is_gerant_stock !== undefined ? (userData.is_gerant_stock ? 1 : 0) : (existing.is_gerant_stock || 0),
            can_manage_products: userData.can_manage_products !== undefined ? (userData.can_manage_products ? 1 : 0) : (existing.can_manage_products || 0),
            // PR√âSERVER : ne pas √©craser si vide depuis Sheets
            device_brand: userData.device_brand || existing.device_brand || '',
            profile_url: userData.profile_url || existing.profile_url || '',
            expo_push_token: userData.expo_push_token || existing.expo_push_token || '',
          };
          
          // CRITIQUE: Toujours mettre √† jour le mot de passe depuis Sheets
          if (userData.password && userData.password.trim() !== '') {
            updateData.password = userData.password;
            syncLogger.info(`   üîë [USERS] Mise √† jour du mot de passe (username match) pour: ${username}`);
          } else {
            // Si pas de mot de passe dans Sheets mais utilisateur existe sans password_hash, utiliser d√©faut
            const db = getDb();
            const userWithHash = db.prepare('SELECT password_hash FROM users WHERE id = ?').get(existing.id);
            if (!userWithHash || !userWithHash.password_hash || userWithHash.password_hash.trim() === '') {
              updateData.password = 'changeme123';
              syncLogger.info(`   üîë [USERS] Pas de mot de passe dans Sheets, utilisation d√©faut (username match) pour: ${username}`);
            }
          }
          
          await usersRepo.update(existing.id, updateData);
          updated++;
          syncLogger.info(`   ‚úÖ [USERS] Utilisateur mis √† jour (username match): ${username}`);
        } else {
          // C) Nouvel utilisateur sans UUID
          syncLogger.info(`   ‚ûï [USERS] Nouvel utilisateur sans UUID: ${username}`);
          
          const newUuid = generateUUID();
          const createData = {
            uuid: newUuid,
            username: username.trim(),
            password: userData.password || 'changeme123', // Utiliser le mot de passe depuis Sheets
            phone: userData.phone || userData.numero || '',
            is_active: userData.is_active !== undefined ? (userData.is_active ? 1 : 0) : 1,
            is_admin: userData.is_admin !== undefined ? (userData.is_admin ? 1 : 0) : 0,
            is_vendeur: userData.is_vendeur !== undefined ? (userData.is_vendeur ? 1 : 0) : 1,
            is_gerant_stock: userData.is_gerant_stock !== undefined ? (userData.is_gerant_stock ? 1 : 0) : 0,
            can_manage_products: userData.can_manage_products !== undefined ? (userData.can_manage_products ? 1 : 0) : 0,
            created_at: userData.created_at || new Date().toISOString(),
            // PR√âSERVER les URLs : utiliser telles quelles depuis Sheets
            device_brand: userData.device_brand || '',
            profile_url: userData.profile_url || '', // Ne pas modifier l'URL
            expo_push_token: userData.expo_push_token || '',
          };
          
          const newUser = await usersRepo.create(createData);
          byUuid.set(newUuid, newUser);
          byUsername.set(normalized, newUser);
          inserted++;
          
          // Pousser vers Sheets pour backfill UUID - PRO et TOP
          syncRepo.addToOutbox('users', newUser.id.toString(), 'upsert', {
            uuid: newUuid,
            username: newUser.username,
            phone: newUser.phone || '',
            is_admin: newUser.is_admin,
            is_active: newUser.is_active,
            is_vendeur: newUser.is_vendeur !== undefined ? newUser.is_vendeur : 1,
            is_gerant_stock: newUser.is_gerant_stock || 0,
            can_manage_products: newUser.can_manage_products || 0,
          });
          
          syncLogger.info(`   ‚úÖ [USERS] Nouvel utilisateur cr√©√© avec UUID g√©n√©r√©: ${username} (UUID=${newUuid})`);
        }
      } catch (error) {
        // Logger les erreurs proprement (√©viter les objets caract√®re par caract√®re)
        const username = userData.username || userData.nom || 'Inconnu';
        const errorDetails = {
          username: username,
          message: String(error?.message || error || 'Erreur inconnue'),
          code: error?.code || 'UNKNOWN'
        };
        syncLogger.error(`   ‚ùå [USERS] Erreur traitement utilisateur #${i + 1} (${username}):`, errorDetails);
        if (error?.stack) {
          syncLogger.error(`   üìã Stack trace:`, String(error.stack).substring(0, 500));
        }
        skipped++;
      }
    }

    syncLogger.info(`üë• [USERS] ==========================================`);
    syncLogger.info(`‚úÖ [USERS] Synchronisation termin√©e: ${inserted} cr√©√©(s), ${updated} mis √† jour, ${repaired} UUID r√©par√©(s), ${skipped} ignor√©(s)`);
    syncLogger.info(`üë• [USERS] ==========================================`);

    // V√©rifier la validit√© de tous les utilisateurs connect√©s apr√®s sync
    await this.checkConnectedUsersValidity();
  }

  /**
   * V√©rifie que tous les utilisateurs actuellement connect√©s sont toujours valides
   * D√©connecte automatiquement ceux qui sont devenus invalides
   */
  async checkConnectedUsersValidity() {
    try {
      syncLogger.info(`üîç [USERS-VALIDITY] V√©rification de la validit√© des utilisateurs connect√©s...`);
      
      // Obtenir l'instance Socket.IO pour notifier les clients
      const { getSocketIO } = await import('../../api/socket.js');
      const io = getSocketIO();
      
      if (!io) {
        syncLogger.warn(`   ‚ö†Ô∏è [USERS-VALIDITY] Socket.IO non disponible, impossible de notifier les clients`);
        return;
      }

      // R√©cup√©rer tous les utilisateurs de la base
      const allUsers = usersRepo.findAll();
      const invalidUsers = [];

      // V√©rifier chaque utilisateur
      for (const user of allUsers) {
        // Si l'utilisateur est inactif, notifier tous les clients connect√©s avec cet user_id
        if (!user.is_active || user.is_active === 0) {
          syncLogger.warn(`   ‚ö†Ô∏è [USERS-VALIDITY] Utilisateur inactif d√©tect√©: ${user.username} (ID: ${user.id}, Phone: ${user.phone})`);
          invalidUsers.push(user);
          
          // Notifier via socket que cet utilisateur doit √™tre d√©connect√©
          io.emit('user:deactivated', {
            user_id: user.id,
            username: user.username,
            phone: user.phone,
            reason: 'Compte d√©sactiv√© lors de la synchronisation'
          });
          
          syncLogger.info(`   üì¢ [USERS-VALIDITY] Notification envoy√©e pour d√©connexion: ${user.username}`);
        }
      }

      if (invalidUsers.length > 0) {
        syncLogger.warn(`   ‚ö†Ô∏è [USERS-VALIDITY] ${invalidUsers.length} utilisateur(s) inactif(s) d√©tect√©(s) et notifi√©(s)`);
      } else {
        syncLogger.info(`   ‚úÖ [USERS-VALIDITY] Tous les utilisateurs sont valides`);
      }
    } catch (error) {
      syncLogger.error(`   ‚ùå [USERS-VALIDITY] Erreur lors de la v√©rification de validit√©:`, error);
    }
  }

  /**
   * Force une synchronisation imm√©diate
   */
  async syncNow() {
    syncLogger.info('üîÑ [SYNC NOW] D√©but synchronisation manuelle (syncNow)');
    try {
      await this.runSyncSafe();
      syncLogger.info('‚úÖ [SYNC NOW] Synchronisation manuelle termin√©e avec succ√®s');
    } catch (error) {
      syncLogger.error('‚ùå [SYNC NOW] Erreur synchronisation manuelle:', error);
      throw error;
    }
  }
}

export const syncWorker = new SyncWorker();


